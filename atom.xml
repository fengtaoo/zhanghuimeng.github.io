<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张慕晖的博客</title>
  
  <subtitle>LUX ET VERITAS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhanghuimeng.github.io/"/>
  <updated>2019-08-26T07:30:32.000Z</updated>
  <id>https://zhanghuimeng.github.io/</id>
  
  <author>
    <name>张慕晖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode Weekly Contest 151总结</title>
    <link href="https://zhanghuimeng.github.io/post/2019-08-26-Leetcode%20Weekly%20Contest%20151%E6%80%BB%E7%BB%93/"/>
    <id>https://zhanghuimeng.github.io/post/2019-08-26-Leetcode Weekly Contest 151总结/</id>
    <published>2019-08-26T07:30:32.000Z</published>
    <updated>2019-08-26T07:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这场比赛让人感觉一言难尽，第一题简直没有让人写下去的欲望……但是最后一题出得很好，是道不错的数据结构题。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/invalid-transactions/description/" target="_blank" rel="noopener">1169. Invalid Transactions</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：52ms</p><h3>题意</h3><p>简直让人没有复述的欲望……</p><p>大概就是让你在某种意义上去重吧。</p><h3>分析</h3><p>没有任何意义的题……通过暴搜枚举即可。主要是数据呈现的方式比较恶心。</p><h3>代码</h3><p>吓得我写了一个Python程序。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invalidTransactions</span><span class="params">(self, transactions)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type transactions: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        transMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> transactions:</span><br><span class="line">            l = t.split(<span class="string">','</span>)</span><br><span class="line">            name, time, amount, city = l[<span class="number">0</span>], int(l[<span class="number">1</span>]), int(l[<span class="number">2</span>]), l[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">in</span> transMap.keys():</span><br><span class="line">                transMap[name] = []</span><br><span class="line">            transMap[name].append((time, city))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> transactions:</span><br><span class="line">            l = t.split(<span class="string">','</span>)</span><br><span class="line">            name, time, amount, city = l[<span class="number">0</span>], int(l[<span class="number">1</span>]), int(l[<span class="number">2</span>]), l[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> amount &gt; <span class="number">1000</span>:</span><br><span class="line">                ans.append(t)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> tup <span class="keyword">in</span> transMap[name]:</span><br><span class="line">                <span class="keyword">if</span> abs(time - tup[<span class="number">0</span>]) &lt;= <span class="number">60</span> <span class="keyword">and</span> city != tup[<span class="number">1</span>]:</span><br><span class="line">                    ans.append(t)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/description/" target="_blank" rel="noopener">1170. Compare Strings by Frequency of the Smallest Character</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：44ms</p><h3>题意</h3><p>定义<code>f(s)</code>是字符串<code>s</code>中最小的字母的出现次数，对于给定的query和word数组，问对于每个query，共有几个word满足<code>f(query) &lt; f(word)</code>。</p><h3>分析</h3><p>以这道题的数据量，直接把每对query和word枚举一遍即可。只要看懂题意，<code>f(s)</code>的比较只是正整数的比较而已。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numSmallerByLeadingCount(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queries, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qSize, wSize;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word: queries) &#123;</span><br><span class="line">            sort(word.begin(), word.end());</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word.length(); i++)</span><br><span class="line">                <span class="keyword">if</span> (word[i] != word[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt++;</span><br><span class="line">            qSize.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word: words) &#123;</span><br><span class="line">            sort(word.begin(), word.end());</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word.length(); i++)</span><br><span class="line">                <span class="keyword">if</span> (word[i] != word[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt++;</span><br><span class="line">            wSize.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(wSize.begin(), wSize.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s: qSize) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s1: wSize)</span><br><span class="line">                <span class="keyword">if</span> (s &lt; s1)</span><br><span class="line">                    cnt++;</span><br><span class="line">            ans.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/description/" target="_blank" rel="noopener">1171. Remove Zero Sum Consecutive Nodes from Linked List</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：28ms</p><h3>题意</h3><p>从一个链表中移除所有和为0的连续结点。可能有多解。</p><h3>分析</h3><p>直接通过前缀和贪心地移除所有和为0的连续结点即可。我写得过于麻烦了，先把每个结点都记录下来，然后算前缀和，标记删除区间，最后再重建链表。更简单的写法可以参考<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; lists;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preSum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个结点</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">            lists.push_back(p);</span><br><span class="line">            val.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (preSum.size() == <span class="number">0</span>) preSum.push_back(p-&gt;val);</span><br><span class="line">            <span class="keyword">else</span> preSum.push_back(p-&gt;val + preSum.back());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标注最大的可删除区间</span></span><br><span class="line">        <span class="keyword">int</span>* flagged = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1005</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1005</span>; i++)</span><br><span class="line">            flagged[i] = <span class="number">0</span>;</span><br><span class="line">        flagged = flagged + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = val.size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; indices;</span><br><span class="line">        indices[<span class="number">0</span>].push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// can delete that</span></span><br><span class="line">            <span class="keyword">if</span> (indices[preSum[i]].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> first = indices[preSum[i]].front();</span><br><span class="line">                flagged[first]++;</span><br><span class="line">                flagged[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            indices[preSum[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除区间和重建</span></span><br><span class="line">        ListNode* last = <span class="literal">NULL</span>;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = flagged[<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (last == <span class="literal">NULL</span>)</span><br><span class="line">                    head = last = lists[i];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    last-&gt;next = lists[i];</span><br><span class="line">                    last = lists[i];</span><br><span class="line">                &#125;</span><br><span class="line">                last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += flagged[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/dinner-plate-stacks/description/" target="_blank" rel="noopener">1172. Dinner Plate Stacks</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：80.26%（572ms）</p><h3>题意</h3><p>有很多栈排在一起，要求实现以下操作：</p><ul><li><code>push</code>：向最左侧的大小未超过<code>capacity</code>的栈顶插入一个元素</li><li><code>pop</code>：从最右侧的非空栈中弹出一个元素</li><li><code>popAtStack</code>：从某一给定<code>index</code>的栈中弹出元素</li></ul><h3>分析</h3><p>这道题的解法大同小异，我一共见到了三个变种：map+set法，set+vector法，以及map+指针法。</p><p>其中我觉得set+vector法最好理解。用一个vector维护从0开始到最后一个有元素的栈（因为题目没有给出栈的范围！），并且用一个set维护目前available的栈（在上述vector空间内的）。具体操作步骤参见代码。我写代码的就是这个版本。当然，因为这道题出的性质的原因，这种写法的很大的一个问题被规避了：如果有一种操作是<code>pushAtStack</code>，且有一组测试数据是不停地往右侧很大的一个<code>index</code>处插入数据再删除，这种方法就得不停地新建栈再删除了。但是并没有这样的操作，所以右侧的变动不会太大。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>我见到的map+指针法是直接用一个map来存储<code>index</code>和栈的对应，然后用两个指针分别标记合法栈的起止位置（即左侧可push位置和右侧可pop位置）。后一个指针的用法非常类似于vector尾部的新建和弹出；当然，考虑到这是一个map，可以做得更好一些，直接查找map尾部的值即可。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>map+set法则是把vector换成map，相当于一个map维护所有栈，一个set维护所有available的栈（在当前所有栈范围内的）。这样vector尾部的删除和插入操作就可以省略了。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.com/problems/dinner-plate-stacks/discuss/366331/C++-Map-Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerPlates</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; available;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; stks;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DinnerPlates(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (available.empty()) &#123;</span><br><span class="line">            <span class="comment">// 在后面新开一个栈</span></span><br><span class="line">            available.insert(stks.size());</span><br><span class="line">            stks.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到左边第一个有空间的栈中</span></span><br><span class="line">        <span class="keyword">int</span> idx = *(available.begin());</span><br><span class="line">        <span class="comment">// 维护vector（因为尾部可能因为空而被删掉了）</span></span><br><span class="line">        <span class="keyword">while</span> (stks.size() &lt;= idx)</span><br><span class="line">            stks.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        stks[idx].push_back(val);</span><br><span class="line">        <span class="keyword">if</span> (stks[idx].size() &gt;= capacity)</span><br><span class="line">            available.erase(idx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接利用popAtStack的实现，弹出最末一个栈的元素</span></span><br><span class="line">        <span class="keyword">if</span> (stks.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> popAtStack(stks.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">popAtStack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= stks.size() || stks[index].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = stks[index].back();</span><br><span class="line">        stks[index].pop_back();</span><br><span class="line">        <span class="comment">// 删掉vector尾部所有为空的栈</span></span><br><span class="line">        <span class="keyword">if</span> (index == stks.size() - <span class="number">1</span> &amp;&amp; stks[index].empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stks.size() &gt; <span class="number">0</span> &amp;&amp; stks.back().empty()) &#123;</span><br><span class="line">                stks.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            available.insert(index);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/366319/JavaC++Python-Greedily-Skip-with-HashMap" target="_blank" rel="noopener">lee215's Solution for Leetcode 1171 - [Java/C++/Python] Greedily Skip with HashMap</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://leetcode.com/problems/dinner-plate-stacks/discuss/366318/C++-Set-Track-Available-Stacks" target="_blank" rel="noopener">vortrubac's Solution for Leetcode 1172 - C++ Set, Track Available Stacks</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://leetcode.com/problems/dinner-plate-stacks/discuss/366368/Java-straightforward-HashMap-+-2-Pointers" target="_blank" rel="noopener">Java straightforward, HashMap + 2 Pointers</a> <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://leetcode.com/problems/dinner-plate-stacks/discuss/366331/C++Python-Solution" target="_blank" rel="noopener">[C++/Python] Solution - Solution 2</a> <a href="#fnref4" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这场比赛让人感觉一言难尽，第一题简直没有让人写下去的欲望……但是最后一题出得很好，是道不错的数据结构题。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Linked List" scheme="https://zhanghuimeng.github.io/tags/alg-Linked-List/"/>
    
      <category term="alg:Map" scheme="https://zhanghuimeng.github.io/tags/alg-Map/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 150总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-150/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-150/</id>
    <published>2019-08-19T09:49:49.000Z</published>
    <updated>2019-08-19T09:49:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次比赛中设计最难的是第四题，可是时限似乎又出了问题。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/description/" target="_blank" rel="noopener">1160. Find Words That Can Be Formed by Characters</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：80ms</p><h3>题意</h3><p>给定一个字符列表和一系列字符串，问能用这些字符组成的字符串的总长度是多少。</p><h3>分析</h3><p>直接判断每个字符串的每个字母的出现次数是否&lt;=要求的字符列表内的出现次数即可。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; W, <span class="built_in">string</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wcnt[<span class="number">26</span>], ccnt[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ccnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ccnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: C)</span><br><span class="line">            ccnt[c - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> w: W) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(wcnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(wcnt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c: w)</span><br><span class="line">                wcnt[c - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (wcnt[i] &gt; ccnt[i]) &#123;</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok)</span><br><span class="line">                ans += w.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" target="_blank" rel="noopener">1161. Maximum Level Sum of a Binary Tree</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：248ms</p><h3>题意</h3><p>返回单层的和最大且层数最小的一棵二叉树的层。</p><h3>分析</h3><p>直接做BFS然后计算每层的和大小即可。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLevelSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelSum(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* node = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> depth = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">while</span> (levelSum.size() &lt;= depth) levelSum.push_back(<span class="number">0</span>);</span><br><span class="line">            levelSum[depth] += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.emplace(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.emplace(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_element(levelSum.begin(), levelSum.end()) - levelSum.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" target="_blank" rel="noopener">1162. As Far from Land as Possible</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：48ms</p><h3>题意</h3><p>给定一个方格图，1表示陆地，0表示水，问所有水格中到陆地最近的格子的距离。</p><h3>分析</h3><p>这道题规模很小，我使用的思路也很简单：</p><ul><li>首先计算出每个水格到正上方和正下方最近的陆地/岸的距离，记为<code>d</code></li><li>显然，该格到最近的陆地的距离不可能超过<code>d</code></li><li>因此分别遍历该格左侧和右侧<code>d</code>个格的距离内的水格，找出离它们最近的正上方/正下方的水格，计算曼哈顿距离</li><li>如果找到了陆地格，则更新<code>d</code></li></ul><p><img src="prob_3.jpg" alt="如图"></p><p>如上图所示，当前格子上下的最小距离是<code>d=3</code>，左上侧（红色线）找到的最小距离是2，左下侧（蓝色线）找到的最小距离是4。</p><p>上述算法的整体时间复杂度为<code>O(N^3)</code>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxUp[<span class="number">100</span>][<span class="number">100</span>], maxDown[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> has1 = <span class="literal">false</span>, has0 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) has1 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> has0 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (has1 &amp;&amp; has0) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (has1 &amp;&amp; has0) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!has1 || !has0) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) maxUp[i][j] = <span class="number">-1e9</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i<span class="number">-1</span>][j] == <span class="number">1</span>) maxUp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> maxUp[i][j] = maxUp[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    maxUp[i][j] = <span class="number">1e9</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) maxUp[i][j] = <span class="number">-1e9</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i+<span class="number">1</span>][j] == <span class="number">1</span>) maxDown[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> maxDown[i][j] = maxDown[i+<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    maxDown[i][j] = <span class="number">1e9</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> d = min(maxUp[i][j], maxDown[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d &amp;&amp; j + k &lt; m; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j+k] != <span class="number">1</span>) &#123;</span><br><span class="line">                        d = min(d, maxUp[i][j + k] + k);</span><br><span class="line">                        d = min(d, maxDown[i][j + k] + k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        d = min(d, k - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d &amp;&amp; j - k &gt;= <span class="number">0</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j - k] != <span class="number">1</span>) &#123;</span><br><span class="line">                        d = min(d, maxUp[i][j - k] + k);</span><br><span class="line">                        d = min(d, maxDown[i][j - k] + k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        d = min(d, k - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/last-substring-in-lexicographical-order/description/" target="_blank" rel="noopener">1163. Last Substring in Lexicographical Order</a></h2><p>标记难度：Hard</p><p>提交次数：2/5</p><p>代码效率：</p><ul><li>后缀数组：868ms</li><li>O(n)：48ms</li></ul><h3>题意</h3><p>找到一个字符串中所有子串中字典序最大的串。</p><h3>分析</h3><p>首先，很显然，字典序最大的串一定是后缀，所以这道题要求我们找到字典序最大的后缀。</p><p>……所以这道题是一道后缀数组模板题，将后缀数组模板复制粘贴即可……</p><p>当然，还有别的做法。显然，最大的后缀一定以字符串中最大的字符开头，所以我们可以首先找到这样的字符。然后，在这样的开头中，之后一个字符必然也需要是最大的。然后以此类推……就会遇到一个问题，如果两个考虑中的字符串相遇（是相遇，不是overlap）了怎么办？如果完全不考虑这个问题，那么这种方法的复杂度恐怕会变得很高（因为可能会遇到<code>aaaa...</code>这种测例）。</p><p><img src="prob_4.png" alt="相遇中的字符串"></p><p>如上图<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，不妨记左半部分为<code>A</code>，中间部分为<code>B</code>，后面的部分为<code>C</code>。已知<code>A == B</code>，则显然有<code>ABC = AAC &gt; AC = BC</code>，否则如果<code>C &gt; A</code>，则最开始根本就不应该选<code>A</code>，而应该选<code>C</code>。因此我们可以根本不考虑相遇时后面的字符串<code>B</code>了，直接把它丢掉即可。</p><p>假设某一时刻共有<code>k</code>个需要考虑的字符串，则最坏情况下也只需要增加字符<code>N / k</code>次（然后就可以开始丢相遇的字符串了），因此总时间复杂度是`O(N)。</p><h3>代码</h3><h4>后缀数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SuffixTree</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Suffix</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">int</span> rank[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Suffix&amp; suffix1, <span class="keyword">const</span> Suffix&amp; suffix2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (suffix1.rank[<span class="number">0</span>] != suffix2.rank[<span class="number">0</span>]) <span class="keyword">return</span> suffix1.rank[<span class="number">0</span>] &lt; suffix2.rank[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (suffix1.rank[<span class="number">1</span>] != suffix2.rank[<span class="number">1</span>]) <span class="keyword">return</span> suffix1.rank[<span class="number">1</span>] &lt; suffix2.rank[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> suffix1.index &lt; suffix2.index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">char</span> s[MAXN];</span><br><span class="line">        <span class="keyword">int</span> suffix[MAXN];</span><br><span class="line">        Suffix suffixTmp[MAXN];</span><br><span class="line">        <span class="keyword">int</span> suffixInv[MAXN];</span><br><span class="line">        <span class="keyword">int</span> lcp[MAXN];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        SuffixTree(<span class="keyword">const</span> <span class="keyword">char</span>* a) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(s, a);</span><br><span class="line">            n = <span class="built_in">strlen</span>(s);</span><br><span class="line">            buildSuffix();</span><br><span class="line">            buildLCP();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对前两个字母排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                suffixTmp[i].index = i;</span><br><span class="line">                suffixTmp[i].rank[<span class="number">0</span>] = s[i];</span><br><span class="line">                suffixTmp[i].rank[<span class="number">1</span>] = i &lt; n - <span class="number">1</span> ? s[i + <span class="number">1</span>] : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(suffixTmp, suffixTmp + n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过前2^k个字母的排序得到前2^(k+1)个字母的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; k) &lt; n; k++) &#123;</span><br><span class="line">                <span class="comment">// 处理上一次的排序结果</span></span><br><span class="line">                <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> prevRank[<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 计算出上一次的真实rank</span></span><br><span class="line">                <span class="comment">// 注意Suffix::rank相同时，真实rank值也相同（不会+1）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (suffixTmp[i].rank[<span class="number">0</span>] != prevRank[<span class="number">0</span>] || suffixTmp[i].rank[<span class="number">1</span>] != prevRank[<span class="number">1</span>]))</span><br><span class="line">                        rank++;</span><br><span class="line">                    <span class="built_in">memcpy</span>(prevRank, suffixTmp[i].rank, <span class="keyword">sizeof</span>(prevRank));</span><br><span class="line">                    <span class="comment">// 将上一次的真实rank记录在rank[0]中，并建立倒排列表</span></span><br><span class="line">                    suffixTmp[i].rank[<span class="number">0</span>] = rank;</span><br><span class="line">                    suffixInv[suffixTmp[i].index] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="comment">// 将rank[1]赋值为s[i+(1&lt;&lt;k)...i+(1&lt;&lt;(k+1))-1]的rank，即新子串后半部分当前的rank</span></span><br><span class="line">                    <span class="keyword">int</span> nextIdx = suffixTmp[i].index + (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">                    <span class="keyword">int</span> nextRank;</span><br><span class="line">                    <span class="keyword">if</span> (nextIdx &gt;= n) nextRank = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> nextRank = suffixTmp[suffixInv[nextIdx]].rank[<span class="number">0</span>];</span><br><span class="line">                    suffixTmp[i].rank[<span class="number">1</span>] = nextRank;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// sort(suffixTmp, suffixTmp + n);</span></span><br><span class="line">                radixSort(suffixTmp, n);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                suffix[i] = suffixTmp[i].index;</span><br><span class="line">                suffixInv[suffix[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildLCP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> lastLCP = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 考虑s[i]的LCP</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// s[i]在后缀数组中是最后一个，所以它的lcp是0</span></span><br><span class="line">                <span class="keyword">if</span> (suffixInv[i] == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    lcp[suffixInv[i]] = <span class="number">0</span>;</span><br><span class="line">                    lastLCP = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// s[j]在后缀数组中恰好在s[i]后面</span></span><br><span class="line">                <span class="keyword">int</span> j = suffix[suffixInv[i] + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (i + lastLCP &lt; n &amp;&amp; j + lastLCP &lt; n &amp;&amp; s[i+lastLCP] == s[j+lastLCP])</span><br><span class="line">                    lastLCP++;</span><br><span class="line">                lcp[suffixInv[i]] = lastLCP;</span><br><span class="line">                <span class="comment">// 重复长度-1</span></span><br><span class="line">                <span class="keyword">if</span> (lastLCP &gt; <span class="number">0</span>)</span><br><span class="line">                    lastLCP--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Suffix tmp[MAXN];</span><br><span class="line">        <span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(Suffix suffixes[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                countSort(suffixes, tmp, n, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(Suffix suffixes[], Suffix tmp[], <span class="keyword">int</span> n, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">int</span>* cnt2 = cnt + <span class="number">1</span>;  <span class="comment">// 处理-1的问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cnt2[suffixes[i].rank[digit]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cnt2[i] += cnt2[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                tmp[--cnt2[suffixes[i].rank[digit]]] = suffixes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(suffixes, tmp, <span class="keyword">sizeof</span>(Suffix) * n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面都是模板，不用看</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">lastSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        SuffixTree suffixTree(s.c_str());</span><br><span class="line">        <span class="keyword">int</span> i = suffixTree.suffix[s.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> s.substr(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>O(n)</h4><p>代码主要参考了<a href="leetcode.com/problems/last-substring-in-lexicographical-order/discuss/361121/Python-O(n)-with-explanation/326578">Leetcode 1163 - Python O(n) with explanation - comment</a>，要不然我自己写不出来这么简洁的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">lastSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cands;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cands.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cands.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newCand;</span><br><span class="line">            <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j: cands)</span><br><span class="line">                <span class="keyword">if</span> (i + j &lt; n)</span><br><span class="line">                    maxn = max(maxn, (<span class="keyword">int</span>) s[i + j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cands.size(); k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = cands[k];</span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; cands[k - <span class="number">1</span>] + i == j)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + j &gt;= n)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>) s[j + i] == maxn)</span><br><span class="line">                    newCand.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            cands = newCand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(cands[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/last-substring-in-lexicographical-order/discuss/361121/Python-O%28n%29-with-explanation/326980" target="_blank" rel="noopener">Leetcode 1163 - Python O(n) with explanation</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次比赛中设计最难的是第四题，可是时限似乎又出了问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:String" scheme="https://zhanghuimeng.github.io/tags/alg-String/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
      <category term="alg:Breadth-first Search" scheme="https://zhanghuimeng.github.io/tags/alg-Breadth-first-Search/"/>
    
      <category term="alg:Suffix Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Suffix-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 149总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-149/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-149/</id>
    <published>2019-08-11T16:35:45.000Z</published>
    <updated>2019-08-11T16:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的最后一题可以说是非常有趣，我从中学到了很多新的idea。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/day-of-the-year/description/" target="_blank" rel="noopener">1154. Day of the Year</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>给定一个形如<code>YYYY-MM-DD</code>的日期字符串，问这个日期是这一年的第几天。</p><h3>分析</h3><p>直接从之前的月份开始遍历，把每月的天数加起来即可。</p><p>所以这其实是一道考闰年的题。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ordinalOfDate</span><span class="params">(<span class="built_in">string</span> date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year = stoi(date.substr(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">int</span> month = stoi(date.substr(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">int</span> day = stoi(date.substr(<span class="number">8</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; month; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">3</span> || i == <span class="number">5</span> || i == <span class="number">7</span> || i == <span class="number">8</span> || i == <span class="number">10</span> || i == <span class="number">12</span>)</span><br><span class="line">                day += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">                    day += <span class="number">29</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    day += <span class="number">28</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                day += <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/" target="_blank" rel="noopener">1155. Number of Dice Rolls With Target Sum</a></h2><p>标记难度：Medium</p><p>提交次数：1/5</p><p>代码效率：36ms</p><h3>题意</h3><p>给定<code>d</code>个骰子，每个骰子有<code>f</code>面，分别标着<code>1...f</code>。问用这些骰子的顶面组成<code>target</code>的方法数量？</p><h3>分析</h3><p>可以进行DP：令<code>g[i][j]</code>表示用前<code>i</code>个骰子组成<code>j</code>的方法总数，则可以立即写出转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g[i][j] = sum(g[i<span class="number">-1</span>][j-k]) (<span class="number">1</span> &lt;= k &lt;= f <span class="keyword">and</span> k &lt;= j)</span><br></pre></td></tr></table></figure><p>总的来说，这是一道比较简单的DP题。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">        LL g[<span class="number">31</span>][<span class="number">1005</span>];  <span class="comment">// 用前i个骰子组成j的方法总数</span></span><br><span class="line">        LL P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                    g[i][j] += g[i - <span class="number">1</span>][j - k];</span><br><span class="line">                    g[i][j] %= P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) g[d][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/swap-for-longest-repeated-character-substring/description/" target="_blank" rel="noopener">1156. Swap For Longest Repeated Character Substring</a></h2><p>标记难度：Medium</p><p>提交次数：1/3</p><p>代码效率：36ms</p><h3>题意</h3><p>给定一个字符串，问字符串中最长的连续字符序列和进行任意一次字符交换后的最长连续字符序列的最大长度？</p><h3>分析</h3><p>直接求字符串中的最长连续字符序列是平凡的，用最大连续子序列的思路即可。问题是“交换”到底意味着什么。以下面这个字符串片段为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....AAAAXAA...</span><br></pre></td></tr></table></figure><p>显然有一种方法使得交换后连续序列的长度变长，就是把最靠左的<code>A</code>或者最靠右的<code>A</code>和中间的<code>X</code>交换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">....XAAAAAA...</span><br><span class="line">....AAAAAAX...</span><br></pre></td></tr></table></figure><p>如果字符串其他位置还存在其他的<code>A</code>，可以把它和<code>X</code>交换，得到更长的连续序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">....AAAAXAA...A...</span><br><span class="line">....AAAAAAA...X...</span><br></pre></td></tr></table></figure><p>当然，这么做的前提是存在，因此要通过计数的方法判断一下当前考虑的两个连续序列之外还有没有别的<code>A</code>了。</p><p>最后一种情况是上一种情况的变体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">....XAAAAX...A...</span><br><span class="line">....XAAAAA...X...</span><br></pre></td></tr></table></figure><h3>代码</h3><p>直接算最长连续子序列的方法不如直接先把相同的字符合并，不过C++写起来未必像Python<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>那样优雅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRepOpt1</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">int</span> leftMax[<span class="number">20005</span>], rightMax[<span class="number">20005</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算向左和向右延伸的最长连续子序列</span></span><br><span class="line">        <span class="keyword">int</span> n = text.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cnt[text[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || text[i] != text[i - <span class="number">1</span>])</span><br><span class="line">                leftMax[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                leftMax[i] = leftMax[i<span class="number">-1</span>] +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span> || text[i] != text[i+<span class="number">1</span>])</span><br><span class="line">                rightMax[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rightMax[i] = rightMax[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 没有交换的情况</span></span><br><span class="line">            ans = max(leftMax[i], ans);</span><br><span class="line">            ans = max(rightMax[i], ans);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (text[i<span class="number">-1</span>] == text[i+<span class="number">1</span>] &amp;&amp; text[i<span class="number">-1</span>] != text[i]) &#123;</span><br><span class="line">                <span class="comment">// 第二种情况</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[text[i<span class="number">-1</span>]-<span class="string">'a'</span>] &gt; leftMax[i<span class="number">-1</span>] + rightMax[i+<span class="number">1</span>])</span><br><span class="line">                    ans = max(ans, <span class="number">1</span> + leftMax[i<span class="number">-1</span>] + rightMax[i+<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 第一种情况</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans = max(ans, leftMax[i<span class="number">-1</span>] + rightMax[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[text[i<span class="number">-1</span>] - <span class="string">'a'</span>] &gt; leftMax[i<span class="number">-1</span>]) ans = max(leftMax[i] + <span class="number">1</span>, ans);</span><br><span class="line">                <span class="keyword">if</span> (cnt[text[i+<span class="number">1</span>] - <span class="string">'a'</span>] &gt; rightMax[i+<span class="number">1</span>]) ans = max(rightMax[i] + <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/online-majority-element-in-subarray/description/" target="_blank" rel="noopener">1157. Online Majority Element In Subarray</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：</p><ul><li>随机法：71.60%（212ms）</li></ul><h3>题意</h3><h3>分析</h3><p>一位<a href="https://leetcode.com/zerotrac2/" target="_blank" rel="noopener">zerotrac2</a>对这道题给出了一些极好的<a href="https://leetcode.com/problems/online-majority-element-in-subarray/discuss/356227/C++-Codes-of-different-approaches-(Random-Pick-Trade-off-Segment-Tree-Bucket)" target="_blank" rel="noopener">分析</a>，比我所知的要强得多，因此我决定把他的分析翻译一下，从中学习一些内容。</p><p>可以说这道题的核心就是这个“majorty”，因为有这一要求，所以很多时间复杂度分析都能成立。</p><h4>Index Search Array</h4><p>其实我也不知道这个结构的学名到底是不是Index Search Array，但总之，对于一个数组，把其中每个元素及其出现的位置都按顺序存储到一个<code>map</code>中，你就得到了这个结构；然后通过二分查找，就可以很方便地查询任意区间内某个元素的出现次数了。</p><h4>Boyer–Moore majority vote algorithm</h4><p>这个算法是求区间内的majority的（注意，并不是众数）；如果majority不存在，它也会输出一个数，而不会告诉你没有majority。算法的思路超简单：假设区间内的majority存在，记为<code>x</code>，则我们把所有不是<code>x</code>的数都找一个<code>x</code>和它一起消去，最后肯定还剩一些<code>x</code>。</p><p>算法伪代码如下<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m = NaN  <span class="comment"># 记录元素</span></span><br><span class="line">i = <span class="number">0</span>    <span class="comment"># 记录出现次数</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        m = x</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> m == x:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h4>随机法</h4><p>给定一个区间，显然可以尝试从中随机选择数字，然后判断该数字是否是该区间中的majority（需要用到Index Search Array）。如果经过多次随机都找不到，则说明不存在majority。通过多次随机，可以将错误概率降低到非常小，可以算是一种成功的算法。</p><h4>Trade-off</h4><p>简单来说，就是在不同查询区间长度对应的时间复杂度之间进行Trade-off。之所以能这么做，是基于下面这个事实：令<code>t</code>表示出现频率的阈值，则在整体数组中出现次数大于<code>t</code>的数不超过<code>N / t</code>个。如果当前查询的阈值<code>threshold &gt;= t</code>，则我们只需考虑前面所说的那些数字。</p><h4>线段树</h4><p>可以推理出，如果一个区间有majority，那么把它均分之后，一定至少有一个区间的majority还是它。因此可以采用线段树算法，建树时合并两个区间的majority时直接用Index Search Array；在查询时，也可以对找到的所有区间的majority都查询总出现次数。</p><h4>桶</h4><p>其实这也是一种trade-off的方法，而且思路有一点类似线段树。将整个区间划分成t个桶，每个桶的大小为<code>n/t</code>；预先计算出每个桶的majority，这样在查询的时候就只需要检查最多<code>n/t</code>个数是否为majority了（其中有最多两个边上的数是现算的）。</p><h3>代码</h3><p>只写得动随机法了，其他的不写了……</p><h4>随机法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MajorityChecker</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; indexArr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Index Search Array初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildIndexArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexArr[arr[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Index Search Array在[l, r]区间内查询</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countInterval</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = indexArr.find(ele);</span><br><span class="line">        <span class="keyword">if</span> (iter == indexArr.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> up_iter = upper_bound(iter-&gt;second.begin(), iter-&gt;second.end(), r);</span><br><span class="line">        <span class="keyword">auto</span> lo_iter = lower_bound(iter-&gt;second.begin(), iter-&gt;second.end(), l);</span><br><span class="line">        <span class="keyword">return</span> up_iter - lo_iter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MajorityChecker(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arr = arr;</span><br><span class="line">        n = arr.size();</span><br><span class="line">        buildIndexArr();</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次在区间内随机选，选20次，错误概率较小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = rand() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">int</span> cnt = countInterval(left, right, arr[idx]);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= threshold)</span><br><span class="line">                <span class="keyword">return</span> arr[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/swap-for-longest-repeated-character-substring/discuss/355852/Python-Groupby" target="_blank" rel="noopener">lee215's Solution for Leetcode 1156 - Python Groupby</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm" target="_blank" rel="noopener">Wikipedia - Boyer–Moore majority vote algorithm</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的最后一题可以说是非常有趣，我从中学到了很多新的idea。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
      <category term="alg:Index Search Array" scheme="https://zhanghuimeng.github.io/tags/alg-Index-Search-Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 148总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-148/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-148/</id>
    <published>2019-08-03T16:21:42.000Z</published>
    <updated>2019-08-03T16:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的题目难度呈现出一种比较诡异的状态。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/description/" target="_blank" rel="noopener">1144. Decrease Elements To Make Array Zigzag</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：100.00%（0ms）</p><h3>题意</h3><p>给定一个整数数组，问将其中的部分元素共-1多少次，才能将这个数组变成一个zigzag数组（数字按index顺序依次增加和减小）。</p><h3>分析</h3><p>题目中已经指出zigzag数组只有两种，因此可以进行分类讨论。因为只能将部分元素-1，所以显然最优的做法就是将那些应该比两侧元素都小的元素减小到合适大小。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = nums;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minn = a[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>)</span><br><span class="line">                minn = min(minn, a[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= minn) &#123;</span><br><span class="line">                n1 += a[i] - minn + <span class="number">1</span>;</span><br><span class="line">                a[i] = minn - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        a = nums;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minn;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) minn = a[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>) minn = a[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> minn = min(a[i<span class="number">-1</span>], a[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= minn) &#123;</span><br><span class="line">                n2 += a[i] - minn + <span class="number">1</span>;</span><br><span class="line">                a[i] = minn - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/binary-tree-coloring-game/description/" target="_blank" rel="noopener">1145. Binary Tree Coloring Game</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：100.00%（0ms）</p><h3>题意</h3><p>有一颗二叉树，Alex和Lee轮流在树上用红色和蓝色对结点染色，在他们分别染完第一个点后，接下来染色的点必须与之前自己染过的对应颜色的点相邻。最后自己染色的结点数量超过总结点数量一半的人获胜。假设两人都以最优策略染色，<strong>Alex已经染了第一个红点</strong>，问此时Lee是否有必胜策略？如果有，他此时应该把哪个点染成蓝色？</p><p>Follow-up<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：如果游戏从头开始，如何判断Alex是否有必胜策略？请给出他染色后必胜的结点集合。</p><h3>分析</h3><p>似乎很多人一开始都直接把题目给理解成Follow-up了，没看见已经染了一个点。不过反正Follow-up也很简单……</p><p>对于树这种数据结构，如果移除一个结点，显然会把树分成（大约，有些部分可能为空）不连通的三份：左子树，右子树，以及树中除了以该结点为根的子树剩下的部分，如下图所示：</p><p><img src="1480-binary-tree-coloring-game.png" alt="原图来自Leetcode"></p><p>对一个结点进行红色染色对蓝色结点来说相当于把树分割了，Lee最多只能对这三部分之中的一部分进行染色；为了防止红色结点继续进入这一部分，他应该首先染最靠近红色结点的那个结点。如果有一部分的结点数量超过总结点数量的一半，则Lee有必胜策略；否则没有。计算结点数量的方法很简单，做一次DFS计算每个结点对应子树的大小，然后就可以立刻得到结点左子树大小、右子树大小和（总结点个数-结点子树大小）了。</p><p>Follow-up就是对每个结点算一遍上述三部分的大小，如果结果是Lee无法获胜，则这个结点对Alex来说是获胜结点。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> subsize[<span class="number">105</span>];</span><br><span class="line">    TreeNode* nodes[<span class="number">105</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        nodes[root-&gt;val] = root;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span> + dfs(root-&gt;left) + dfs(root-&gt;right);</span><br><span class="line">        subsize[root-&gt;val] = sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">btreeGameWinningMove</span><span class="params">(TreeNode* root, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = dfs(root);</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">        TreeNode* redNode = nodes[x];</span><br><span class="line">        maxn = redNode-&gt;left != <span class="literal">NULL</span> ? subsize[redNode-&gt;left-&gt;val] : <span class="number">0</span>;</span><br><span class="line">        maxn = redNode-&gt;right != <span class="literal">NULL</span> ? max(maxn, subsize[redNode-&gt;right-&gt;val]) : <span class="number">0</span>;</span><br><span class="line">        maxn = max(maxn, sum - subsize[x]);</span><br><span class="line">        <span class="keyword">return</span> maxn &gt; n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/snapshot-array/description/" target="_blank" rel="noopener">1146. Snapshot Array</a></h2><p>标记难度：Medium</p><p>提交次数：1/3</p><p>代码效率：87.91%（264ms）</p><h3>题意</h3><p>实现一个包含以下几种操作的数组：</p><ul><li><code>set(index, val)</code>：将<code>index</code>处设为<code>val</code></li><li><code>snap()</code>：保存数组历史记录</li><li><code>get(index, snap_id)</code>：获得<code>index</code>处在<code>snap_id</code>次记录时的值</li></ul><h3>分析</h3><p>这大概就是传说中的可持久化数据结构了。不知道直接上棵可持久化线段树之类的方法是不是可取，但是眼下这样做就够了。</p><p>如果每次snapshot都存一遍数组，就会MLE，所以不能这样存。显然，每两次snapshot之间数组的变化并不是很大（准确地说，只有被<code>set</code>的那些<code>index</code>变化了）。那么，我们就可以在每次snapshot的时候，把发生变化的<code>index</code>对应的<code>snap_id</code>和变化之后的值存到一个数组里；之后在<code>get</code>的时候直接二分查找即可。</p><p>一个值得注意的事情是，每次snapshot的时候不能进行<code>O(N)</code>的操作（比如扫描一遍新数组和旧数组，看看有什么差别），所以我换成用一个<code>map</code>来存发生了变化的值。当然，实际上不必这么复杂，直接给每个数组开一个<code>map</code>都可以……<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; changes;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curChanges;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> snap_id;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SnapshotArray(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        n = length;</span><br><span class="line">        changes = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;(length, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">        snap_id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        curChanges[index] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p: curChanges)</span><br><span class="line">            changes[p.first].emplace_back(snap_id, p.second);</span><br><span class="line">        curChanges.clear();</span><br><span class="line">        <span class="keyword">return</span> snap_id++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = upper_bound(changes[index].begin(), changes[index].end(), make_pair(snap_id, <span class="number">1000000005</span>));</span><br><span class="line">        <span class="keyword">if</span> (iter == changes[index].begin())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        iter--;</span><br><span class="line">        <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/" target="_blank" rel="noopener">1147. Longest Chunked Palindrome Decomposition</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：50.69%（8ms）</p><h3>题意</h3><p>将一个字符串<code>a</code>分成若干个<code>a_1, a_2, ..., a_k</code>，使得<code>k</code>最大且满足<code>a_1 = a_k</code>，<code>a_2 = a_(k-1)</code>……，求<code>k</code>的最大值。</p><h3>分析</h3><p>这道题标的是Hard，但是通过率巨高。</p><p>为什么呢……？</p><p>因为直接贪心就好啦……！！！</p><p>证明见下图<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>即可：</p><p><img src="palindrome_proof.png" alt="图来自lee215"></p><p>从图中可以看出，如果当前剩余的字符串中同时有两个不同长度的字符串都匹配，则由于它们位于相同的位置，长字符串必然包含两份短字符串，无论是否重叠，都可以把长字符串拆成至少两份，这样这一解法就必然比选择更长的字符串好，所以直接选两侧最短的匹配字符串即可。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestDecomposition</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = text.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - i - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = text.substr(last, i - last + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> s2 = text.substr(n - i - <span class="number">1</span>, i - last + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">                last = i + <span class="number">1</span>;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意全部匹配完的极端情况</span></span><br><span class="line">        <span class="keyword">if</span> (last &lt; (n + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/binary-tree-coloring-game/discuss/350570/JavaC++Python-Simple-recursion-and-Follow-Up" target="_blank" rel="noopener">lee215's Solution for Leetcode 1145 - [Java/C++/Python] Simple recursion and Follow-Up</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://leetcode.com/problems/snapshot-array/discuss/350562/Python-Binary-Search" target="_blank" rel="noopener">lee215's Solution for Leetcode 1146 - [Python] Binary Search</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://leetcode.com/problems/longest-chunked-palindrome-decomposition/discuss/350560/JavaC++Python-Easy-Greedy-with-Prove" target="_blank" rel="noopener">图源：[Java/C++/Python] Easy Greedy with Prove</a> <a href="#fnref3" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的题目难度呈现出一种比较诡异的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Binary Search" scheme="https://zhanghuimeng.github.io/tags/alg-Binary-Search/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 147总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-147/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-147/</id>
    <published>2019-07-27T01:49:10.000Z</published>
    <updated>2019-07-29T01:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次比赛做得有点费劲……</p><a id="more"></a><h2><a href="https://leetcode.com/problems/n-th-tribonacci-number/description/" target="_blank" rel="noopener">1137. N-th Tribonacci Number</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>求一个递推数列的第<code>n</code>项。</p><h3>分析</h3><p>因为<code>n</code>很小，所以直接线性递推就可以了。（不过不做优化的递归大概还是会爆……）</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t0 = <span class="number">0</span>, t1 = <span class="number">1</span>, t2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = t0 + t1 + t2;</span><br><span class="line">            t0 = t1;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/alphabet-board-path/description/" target="_blank" rel="noopener">1138. Alphabet Board Path</a></h2><p>标记难度：Medium</p><p>提交次数：1/2</p><p>代码效率：4ms</p><h3>题意</h3><p>有一个方格图是这样的（空的地方没有道路）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a b c d e</span><br><span class="line">f g h i j</span><br><span class="line">k l m n o</span><br><span class="line">p q r s t</span><br><span class="line">u v w x y</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>从<code>a</code>处开始，要求给出一条能够打印出目标字符串的最短路线。</p><h3>分析</h3><p>这个方格图上最难处理的地方显然是<code>z</code>。当然，处理方法实际上很简单：先走到<code>z</code>正上方的<code>u</code>，再向下一格到<code>z</code>；其他字母间的相互移动直接走曼哈顿距离就可以了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 坐标差对应的路线</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(dx); i++)</span><br><span class="line">            ans += dx &lt; <span class="number">0</span> ? <span class="string">'U'</span> : <span class="string">'D'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(dy); i++)</span><br><span class="line">            ans += dy &lt; <span class="number">0</span> ? <span class="string">'L'</span> : <span class="string">'R'</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从一个字母到另一个字母的路线</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">calc2</span><span class="params">(<span class="keyword">char</span> last, <span class="keyword">char</span> next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="string">'z'</span> &amp;&amp; next != <span class="string">'z'</span>)</span><br><span class="line">            <span class="keyword">return</span> calc((next - <span class="string">'a'</span>) / <span class="number">5</span> - (last - <span class="string">'a'</span>) / <span class="number">5</span>, (next - <span class="string">'a'</span>) % <span class="number">5</span> - (last - <span class="string">'a'</span>) % <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="string">'z'</span> &amp;&amp; next == <span class="string">'z'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="string">'z'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'U'</span> + calc((next - <span class="string">'a'</span>) / <span class="number">5</span> - (<span class="string">'u'</span> - <span class="string">'a'</span>) / <span class="number">5</span>, (next - <span class="string">'a'</span>) % <span class="number">5</span> - (<span class="string">'u'</span> - <span class="string">'a'</span>) % <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">'z'</span>)</span><br><span class="line">            <span class="keyword">return</span> calc((<span class="string">'u'</span> - <span class="string">'a'</span>) / <span class="number">5</span> - (last - <span class="string">'a'</span>) / <span class="number">5</span>, (<span class="string">'u'</span> - <span class="string">'a'</span>) % <span class="number">5</span> - (last - <span class="string">'a'</span>) % <span class="number">5</span>) + <span class="string">'D'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alphabetBoardPath</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">            ans += i == <span class="number">0</span> ? calc2(<span class="string">'a'</span>, target[i]) : calc2(target[i<span class="number">-1</span>], target[i]);</span><br><span class="line">            ans += <span class="string">'!'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/largest-1-bordered-square/description/" target="_blank" rel="noopener">1139. Largest 1-Bordered Square</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：8ms</p><h3>题意</h3><p>给定一个01矩阵，问其中最大的边框均为1的正方形的面积。</p><h3>分析</h3><p>直接用两个数组维护每个位置向下和向右的连续1的最大数量，然后在每个位置上枚举全部可能的正方形的变长即可，时间复杂度是<code>O(N^3)</code>。似乎是一种平凡的DP的变形。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDown[<span class="number">101</span>][<span class="number">101</span>], maxRight[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">memset</span>(maxDown, <span class="number">0</span>, <span class="keyword">sizeof</span>(maxDown));</span><br><span class="line">        <span class="built_in">memset</span>(maxRight, <span class="number">0</span>, <span class="keyword">sizeof</span>(maxRight));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    maxDown[i][j] = maxRight[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxDown[i][j] = i == n - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">1</span> + maxDown[i+<span class="number">1</span>][j];</span><br><span class="line">                maxRight[i][j] = j == m - <span class="number">1</span> ? <span class="number">1</span> : <span class="number">1</span> + maxRight[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = ans + <span class="number">1</span>; i+l &lt;= n &amp;&amp; maxRight[i][j] &gt;= l &amp;&amp; j + l &lt;= m; l++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxDown[i][j] &gt;= l &amp;&amp; maxRight[i][j] &gt;= l &amp;&amp; maxDown[i][j+l<span class="number">-1</span>] &gt;= l &amp;&amp; maxRight[i+l<span class="number">-1</span>][j] &gt;= l)</span><br><span class="line">                        ans = max(ans, l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/stone-game-ii/description/" target="_blank" rel="noopener">1140. Stone Game II</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：0ms</p><h3>题意</h3><p>两个玩家对一列石子堆轮流进行操作：初始时<code>M = 1</code>，每次一个人可以取最前面的<code>X</code>堆石子，其中<code>X</code>满足<code>1 &lt;= X &lt;= 2*M</code>，然后令<code>M = max(M, X)</code>；之后换另一个人操作。问两人都以最佳策略操作时，第一个人最多可以得到多少石子？</p><h3>分析</h3><p>这显然是个MinMax问题，但是我最开始的时候把状态转移方向弄反了，搞成了从后向前转移；实际上应该是从前向后。（显然，状态转移方向和状态的数字大小没有必然联系。）除此之外，这道题还是很简单的。</p><p>（专门看了一下，<a href="https://leetcode.com/problems/stone-game/description/" target="_blank" rel="noopener">877. Stone Game</a>的确也是Alex和Lee玩游戏……）</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">102</span>][<span class="number">102</span>][<span class="number">2</span>];  <span class="comment">// i, M, player0/1</span></span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i][M][<span class="number">0</span>] != <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        f[i][M][<span class="number">0</span>] = f[i][M][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">1</span>; X &lt;= <span class="number">2</span> * M; X++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + X &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> i1 = i + X, M1 = max(X, M);</span><br><span class="line">            calc(i1, M1);</span><br><span class="line">            <span class="keyword">if</span> (sum[i][i1<span class="number">-1</span>] + f[i1][M1][<span class="number">1</span>] &gt; f[i][M][<span class="number">0</span>]) &#123;</span><br><span class="line">                f[i][M][<span class="number">0</span>] = sum[i][i1<span class="number">-1</span>] + f[i1][M1][<span class="number">1</span>];</span><br><span class="line">                f[i][M][<span class="number">1</span>] = f[i1][M1][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        n = piles.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i][i] = piles[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                sum[i][j] = sum[i][j<span class="number">-1</span>] + piles[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        calc(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次比赛做得有点费劲……&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
      <category term="alg:Minmax" scheme="https://zhanghuimeng.github.io/tags/alg-Minmax/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 146总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-146/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-146/</id>
    <published>2019-07-23T02:07:39.000Z</published>
    <updated>2019-07-27T01:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周的第四题是道富含思维含量的好题，换句话说，就是一道让我做了一个小时仍然毫无头绪，只好去看题解，结果连题解都看不太懂的题。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/" target="_blank" rel="noopener">1128. Number of Equivalent Domino Pairs</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：25.52%（60ms）</p><h3>题意</h3><p>给定一个数组的多米诺骨牌（意思是上面写着两个1-6的数字的牌，数字顺序无关），问相等的骨牌对数。</p><h3>分析</h3><p>直接搞个map统计一下每种等价的牌的数量，然后直接<code>C(n, 2)</code>就可以了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mmap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d: dominoes) &#123;</span><br><span class="line">            sort(d.begin(), d.end());</span><br><span class="line">            mmap[d]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p: mmap) &#123;</span><br><span class="line">            ans += (p.second - <span class="number">1</span>) * p.second / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/shortest-path-with-alternating-colors/description/" target="_blank" rel="noopener">1129. Shortest Path with Alternating Colors</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：25.52%（60ms）</p><h3>题意</h3><p>给定一个有向图（边权均为1），图中的边分成红蓝两种颜色，问从0出发到每个点的红蓝（或蓝红）交替的路径的最小长度。</p><h3>分析</h3><p>这道题的本质是拆点。把每个点都拆成一个红点和一个蓝点，认为从红点只能从红边出发（并到达蓝点），从蓝点只能从蓝边出发（并到达红点）。然后就可以进行多源点BFS了（两个源点分别是红0和蓝0）。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestAlternatingPaths(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; red_edges, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; blue_edges) &#123;</span><br><span class="line">        <span class="keyword">bool</span> visited[<span class="number">105</span>][<span class="number">2</span>]; <span class="comment">// 0=red, 1=blue</span></span><br><span class="line">        <span class="keyword">int</span> dist[<span class="number">105</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">105</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: red_edges) &#123;</span><br><span class="line">            G[v[<span class="number">0</span>]][<span class="number">0</span>].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: blue_edges) &#123;</span><br><span class="line">            G[v[<span class="number">0</span>]][<span class="number">1</span>].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">1</span>, <span class="keyword">sizeof</span>(dist));  <span class="comment">// note: the longest path len can exceed n</span></span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = visited[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = dist[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        q.emplace(<span class="number">0</span>, <span class="number">0</span>); q.emplace(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front().first, color = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: G[u][<span class="number">1</span> - color]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v][<span class="number">1</span> - color]) &#123;</span><br><span class="line">                    visited[v][<span class="number">1</span> - color] = <span class="literal">true</span>;</span><br><span class="line">                    dist[v][<span class="number">1</span> - color] = dist[u][color] + <span class="number">1</span>;</span><br><span class="line">                    q.emplace(v, <span class="number">1</span> - color);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans.push_back(min(dist[i][<span class="number">0</span>], dist[i][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (ans.back() &gt; <span class="number">1e5</span>)</span><br><span class="line">                ans.back() = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/description/" target="_blank" rel="noopener">1130. Minimum Cost Tree From Leaf Values</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：25.52%（16ms）</p><h3>题意</h3><p>给定一个正整数数组，用它们作为叶子构造一棵每个结点的子结点数量都是0或2的二叉树，且这些数在所有叶子中从左到右依次出现。记每个非叶结点的值是它的左右子树中各自最大的叶结点的乘积，求所有合法的树中非叶结点值的和的最小值。</p><h3>分析</h3><p>这道题的题目描述简直绕上天了，但形式化出来之后会发现实际上很简单。显然，我们可以自顶向下递归构造出一棵树：每一步把数组分成左右两个部分，左边用于构造左子树，右边用于构造右子树，然后再合并起来。于是每个数组区间都可以代表一棵子树。然后就可以DP了，时间复杂度是<code>O(N^2)</code>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> maxn[<span class="number">41</span>][<span class="number">41</span>];</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">41</span>][<span class="number">41</span>];  <span class="comment">// smallest node sum</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxn[i][i] = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maxn[i][j] = max(maxn[i][j<span class="number">-1</span>], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt;= n; i++) &#123;</span><br><span class="line">                f[i][i + l - <span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">                <span class="comment">// split: j = left count</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; l; j++) &#123;</span><br><span class="line">                    f[i][i+l<span class="number">-1</span>] = min(f[i][i+l<span class="number">-1</span>], f[i][i+j<span class="number">-1</span>] + f[i+j][i+l<span class="number">-1</span>] + maxn[i][i+j<span class="number">-1</span>] * maxn[i+j][i+l<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; i + l - <span class="number">1</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; f[i][i+l<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/maximum-of-absolute-value-expression/description/" target="_blank" rel="noopener">1131. Maximum of Absolute Value Expression</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：69.43%（40ms）</p><h3>题意</h3><p>给定两个等长的整数数组<code>arr1</code>和<code>arr2</code>，求<code>|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|</code>的最大值。</p><h3>分析</h3><p>题意简明易懂，然而真不会做。最后只好跑到Discussion里找了一篇我认为最好懂的<a href="https://leetcode.com/problems/maximum-of-absolute-value-expression/discuss/340051/Python-very-intuitive-math-solution-with-explanation-O(N)" target="_blank" rel="noopener">题解</a>，才明白应该怎么做（然而我还是不懂这怎么能想出来）。</p><p>主要思路是这样的：为简单起见，用<code>a</code>表示<code>arr1</code>，<code>b</code>表示<code>arr2</code>，设<code>i &gt; j</code>，则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|a[i] - a[j]| + |b[i] - b[j]| + |i - j|</span><br><span class="line">= |a[i] - a[j]| + |b[i] - b[j]| + i - j</span><br></pre></td></tr></table></figure><p>显然上式的取值有以下4种可能情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">= a[i] - a[j] + b[i] - b[j] + i - j = (a[i] + b[i] + i) - (a[j] + b[j] + j)  (a[i] &gt;= a[j], b[i] &gt;= b[j])</span><br><span class="line">= a[i] - a[j] + b[j] - b[i] + i - j = (a[i] - b[j] + i) - (a[j] - b[j] + j)  (a[i] &gt;= a[j], b[i] &lt; b[j])</span><br><span class="line">= a[j] - a[i] + b[i] - b[j] + i - j = (-a[i] + b[i] + i) - (-a[j] + b[j] + j) (a[i] &lt; a[j], b[i] &gt;= b[j])</span><br><span class="line">= a[j] - a[i] + b[j] - b[i] + i - j = (-a[i] - b[i] + i) - (-a[j] - b[j] + j) (a[i] &lt; a[j], b[i] &lt; b[j])</span><br></pre></td></tr></table></figure><p>对式子进行变化之后，可以看出，每种情况都可以被看成是两项的差，它们的形式相同，且都只与一个单独的index相关。于是就可以得出一种简单的方法：遍历数组，为每种情况的项分别求出最大值和最小值，于是整体的最大值就等于每种情况的最大值减最小值中的最大值。</p><p>于是就会产生两个问题。第一个问题是，假如找到的最大值和最小值对不满足<code>i &gt; j</code>的要求呢？（显然，为了规避这个问题，可以把对i和j的讨论也加进去，然后就会变成八种情况；但实际上并不需要。）不妨假设对于找到的最大值和最小值，<code>i &lt;= j</code>，则立刻可以发现<code>|a[i] - a[j]| + |b[i] - b[j]| + |i - j| = |a[j] - a[i]| + |b[j] - b[i]| + |j - i|</code>，也就是说至少会有另一对满足<code>i &lt; j</code>的最大值和最小值。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>另一个问题是，如果找到的整体最大值和最小值对不满足元素大小的要求呢？以第一种情况为例，如何保证<code>a[i] &gt;= a[j], b[i] &gt;= b[j]</code>？可以采用反证法。不妨假设<code>a[i] &lt; a[j], b[i] &gt;= b[j]</code>，则此时很容易看出，<code>(-a[i] + b[i] + i) - (-a[j] + b[j] + j) &gt; (a[i] + b[i] + i) - (a[j] + b[j] + j)</code>，这不符合取到的值对是第一种情况的要求。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAbsValExpr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn[<span class="number">4</span>], minn[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            maxn[i] = <span class="number">-1</span>;</span><br><span class="line">            minn[i] = <span class="number">1e9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr1.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x[<span class="number">4</span>];</span><br><span class="line">            x[<span class="number">0</span>] = arr1[i] + arr2[i] + i;</span><br><span class="line">            x[<span class="number">1</span>] = arr1[i] - arr2[i] + i;</span><br><span class="line">            x[<span class="number">2</span>] = - arr1[i] + arr2[i] + i;</span><br><span class="line">            x[<span class="number">3</span>] = - arr1[i] - arr2[i] + i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                maxn[j] = max(maxn[j], x[j]);</span><br><span class="line">                minn[j] = min(minn[j], x[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            ans = max(ans, maxn[j] - minn[j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="leetcode.com/problems/maximum-of-absolute-value-expression/discuss/340051/Python-very-intuitive-math-solution-with-explanation-O(N)/309831">Leetcode 1131 Discussion - What if the max/min you recorded don't align with the i &lt; j assumption?</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周的第四题是道富含思维含量的好题，换句话说，就是一道让我做了一个小时仍然毫无头绪，只好去看题解，结果连题解都看不太懂的题。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Math" scheme="https://zhanghuimeng.github.io/tags/alg-Math/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
      <category term="alg:Breadth-First Search" scheme="https://zhanghuimeng.github.io/tags/alg-Breadth-First-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 145总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-145/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-145/</id>
    <published>2019-07-16T00:47:45.000Z</published>
    <updated>2019-07-23T04:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次比赛有（bu）幸遇到了两道我不大确定怎么做的题，所以拖到了现在。当然，也算是学习到了一个新的范式吧。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/relative-sort-array/description/" target="_blank" rel="noopener">1122. Relative Sort Array</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：42.90%（8ms）</p><h3>题意</h3><p>给定两个数组，其中一个数组的值是互异的，另一个数组的值全都包含在此数组中，要求将后一个数组排序，使得元素的出现顺序与第一个数组相符。</p><h3>分析</h3><p>这道题最好的做法显然是使用哈希表（或map）统计后一个数组中的元素，然后直接把这个数组重新构建出来。</p><p>以及我觉得这道题可以加一些follow-up，比如如何进行原地排序，以及能否在附加空间复杂度为<code>O(1)</code>的要求下排序。原地排序很简单，后一个感觉很难做到……</p><h3>代码</h3><p>写的时候直接重新构造了一个数组，不过改成原地的形式应该是非常简单的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; relativeSortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; myMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: arr1) myMap[x]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: arr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myMap[x]; i++)</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">            myMap.erase(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: myMap) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.second; i++)</span><br><span class="line">                ans.push_back(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/" target="_blank" rel="noopener">1123. Lowest Common Ancestor of Deepest Leaves</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：7.23%（32ms）</p><h3>题意</h3><p>求出树中所有深度最大的叶子的LCA。</p><h3>分析</h3><p>这道题的题面比较令人困惑，实际上是这样的：首先树中的所有的叶子有一个最大的深度，然后对于深度和这个值相同的所有叶子，求它们的共同LCA。因为这实在是太困惑了，我干脆摸出了一个LCA模板，直接求出了所有深度最大的叶子，然后用模板求了LCA。当然，因为LCA的原始模板返回的是结点编号，我还专门弄了一个数组来存编号到<code>TreeNode*</code>的映射。</p><p>这么做显然能work，但是有（fei）点（chang）蠢。lee给出了两种<a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/discuss/334577/JavaC++Python-Two-Recursive-Solution" target="_blank" rel="noopener">非常简洁的递归写法</a>，其中第一种的思路很简单：写一个递归函数，返回(LCA, 最大深度)，然后对左右子树分别调用这个函数。如果两棵子树的高度不同，则显然最大深度的叶子只存在更深的子树中，那么另一棵子树就不用管了，LCA也不变；否则LCA是当前树根。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LCA</span> &#123;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">1002</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">int</span> maxDepth;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; deepestLeaves;</span><br><span class="line">        <span class="keyword">int</span> father[<span class="number">1002</span>][<span class="number">21</span>];</span><br><span class="line">        LL dist[<span class="number">1002</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LCA初始化</span></span><br><span class="line">        LCA(TreeNode* root) &#123;</span><br><span class="line">            nodes = <span class="built_in">vector</span>&lt;TreeNode*&gt;(<span class="number">1002</span>, <span class="literal">NULL</span>);</span><br><span class="line">            maxDepth = <span class="number">-1</span>;</span><br><span class="line">            dfs(root, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">                    father[i][j] = father[father[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算父结点和结点深度（用于LCA）</span></span><br><span class="line">        <span class="comment">// 除此之外的部分基本都是LCA模板……</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">            nodes[cur-&gt;val] = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (depth == maxDepth) deepestLeaves.push_back(cur);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                    deepestLeaves.clear();</span><br><span class="line">                    deepestLeaves.push_back(cur);</span><br><span class="line">                    maxDepth = depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            father[cur-&gt;val][<span class="number">0</span>] = parent == <span class="number">-1</span> ? cur-&gt;val : parent;</span><br><span class="line">            dist[cur-&gt;val] = depth;</span><br><span class="line">            dfs(cur-&gt;left, cur-&gt;val, depth + <span class="number">1</span>);</span><br><span class="line">            dfs(cur-&gt;right, cur-&gt;val, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算x和y的LCA</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getLCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; dist[y]) swap(x, y);</span><br><span class="line">            <span class="keyword">int</span> d = dist[x] - dist[y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                    x = father[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (father[x][i] != father[y][i]) &#123;</span><br><span class="line">                    x = father[x][i];</span><br><span class="line">                    y = father[y][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据LCA和深度计算x和y在树中的距离</span></span><br><span class="line">        <span class="function">LL <span class="title">getDist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> fa = getLCA(x, y);</span><br><span class="line">            <span class="keyword">return</span> dist[x] + dist[y] - <span class="number">2</span> * dist[fa];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="function">LCA <span class="title">tool</span><span class="params">(root)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> r = tool.deepestLeaves.front()-&gt;val;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode* x: tool.deepestLeaves) &#123;</span><br><span class="line">            r = tool.getLCA(r, x-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tool.nodes[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/longest-well-performing-interval/description/" target="_blank" rel="noopener">1124. Longest Well-Performing Interval</a></h2><p>标记难度：Medium</p><p>提交次数：1/2</p><p>代码效率：33.51%（56ms）</p><h3>题意</h3><p>给定一个只包含1和-1的数组，求最大的和大于0的连续区间的长度。</p><h3>分析</h3><p>这道题的题目描述中的<code>[9,9,6]</code>简直充满了恶意……</p><p>我不会做这道题，当初想了很多乱七八糟的方案也没做出来，现在想想，其实一年前似乎做过类似的题。于是在评论区里翻了翻，看到了一道很平凡的题：<a href="https://leetcode.com/problems/subarray-sum-equals-k/description/" target="_blank" rel="noopener">560. Subarray Sum Equals K</a>。啊，这个贪心我会啊！怎么扩展一下就不会了呢！</p><p>仍然参考<a href="https://leetcode.com/problems/longest-well-performing-interval/discuss/334565/JavaC++Python-O(N)-Solution-Life-needs-996-and-669" target="_blank" rel="noopener">lee的解法</a>：遍历数组，计算当前的前缀和，然后进行贪心。显然，有两种情况：第一种是当前的前缀和已经大于0了，这个前缀是合法的；另一种是前缀和&lt;=0了，如果此时存在一个以当前元素结尾的合法区间，在前面一定存在至少一个前缀和是当前的前缀和-1（考虑到每个元素都是1或-1，所以前缀和的变化可以看成是连续的），且选择它是最优的（因为可能的长度最大）。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; posMap;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        posMap[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hours.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hours[i] &gt; <span class="number">8</span>) cur++;</span><br><span class="line">            <span class="keyword">else</span> cur--;</span><br><span class="line">            <span class="comment">// this is crucial</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) ans = max(ans, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (posMap.find(cur - <span class="number">1</span>) != posMap.end())</span><br><span class="line">                ans = max(ans, i - posMap[cur - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (posMap.find(cur) == posMap.end())</span><br><span class="line">                posMap[cur] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/smallest-sufficient-team/description/" target="_blank" rel="noopener">1125. Smallest Sufficient Team</a></h2><p>标记难度：Hard</p><p>提交次数：1/4</p><p>代码效率：54.44%（120ms）</p><h3>题意</h3><p>给定一个要求的编号列表和每个人有的列表，问最少取哪些人，才能覆盖所有要求的列表。</p><h3>分析</h3><p>这显然是一个状态DP问题，但是我写的时候出了很多麻烦。记<code>n = people.size()</code>，<code>m = req_skills.size()</code>，我本来设计用<code>f[n][1 &lt;&lt; m]</code>的状态数组，从前向后转移（而不是从后向前）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i+<span class="number">1</span>][j | skill[i+<span class="number">1</span>]] = min(f[i+<span class="number">1</span>][j | skill[i+<span class="number">1</span>]], f[i][j] + <span class="number">1</span>)</span><br><span class="line">f[i+<span class="number">1</span>][j] = min(f[i+<span class="number">1</span>][j], f[i][j])</span><br></pre></td></tr></table></figure><p>结果发现要求把具体的选择方案也求出来。这也不是大问题，于是我打算开60 * 65536个<code>vector&lt;int&gt;</code>，于是问题来了，我发现内存爆了……当时脑抽了一下，没想到递推时只用到前一步的结果，可以节省空间，于是看了看数据范围（只有60），干脆把<code>vector&lt;int&gt;</code>塞到一个<code>long long int</code>里去了，于是代码里满地都是<code>__builtin_popcountll</code>。</p><p>还是lee对这个解法的描述<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>说得最好：</p><blockquote><p><code>dp[skill_set]</code> is a sufficient team to cover the <code>skill_set</code>.<br>For each people,<br>update <code>his_skill</code> with all current combinations of <code>skill_set</code> in <code>dp</code>.</p></blockquote><p>简单来说，存下当前出现过的每种组合的最小队伍，然后每加一个人，尝试把他加到这些队伍里，更新原来的队伍和新出现的组合。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestSufficientTeam(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; req_skills, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; skillMap;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req_skills.size(); i++)</span><br><span class="line">            skillMap[req_skills[i]] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> peopleSkills[<span class="number">65</span>], n = people.size(), m = req_skills.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            peopleSkills[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">string</span> s: people[i])</span><br><span class="line">                <span class="keyword">if</span> (skillMap.find(s) != skillMap.end())</span><br><span class="line">                    peopleSkills[i] |= <span class="number">1</span> &lt;&lt; skillMap[s];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line">        LL f[<span class="number">65</span>][<span class="number">65536</span>];</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][peopleSkills[<span class="number">0</span>]] |= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i][peopleSkills[i]] = (LL) <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i<span class="number">-1</span>][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (f[i][j] == <span class="number">0</span> || __builtin_popcountll(f[i<span class="number">-1</span>][j]) &lt; __builtin_popcountll(f[i][j]))</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">int</span> x = j | peopleSkills[i];</span><br><span class="line">                <span class="keyword">if</span> (f[i][x] == <span class="number">0</span> || __builtin_popcountll(f[i<span class="number">-1</span>][j]) + <span class="number">1</span> &lt; __builtin_popcountll(f[i][x]))</span><br><span class="line">                    f[i][x] = f[i<span class="number">-1</span>][j] | ((LL) <span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LL minn = ((LL) <span class="number">1</span> &lt;&lt; <span class="number">63</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (f[i][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; __builtin_popcountll(f[i][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>]) &lt; __builtin_popcountll(minn))</span><br><span class="line">                minn = f[i][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (minn &amp; ((LL) <span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/smallest-sufficient-team/discuss/334572/Python-DP-Solution" target="_blank" rel="noopener">lee215's Solution for Leetcode 1125 - [Python] DP Solution</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次比赛有（bu）幸遇到了两道我不大确定怎么做的题，所以拖到了现在。当然，也算是学习到了一个新的范式吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 144总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-144/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-144/</id>
    <published>2019-07-07T20:57:44.000Z</published>
    <updated>2019-07-07T22:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次的题比较水，甚至都没有Hard的。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/defanging-an-ip-address/description/" target="_blank" rel="noopener">1108. Defanging an IP Address</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>把一个IPv4地址中的每个点都换成<code>[.]</code>。</p><h3>分析</h3><p>这道题实在是过于简单了。我觉得对于C++来说，最好的方法还是直接把字符串过一遍，但如果是Python之类的话，估计正则或者replace更直接。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: address) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) ans += <span class="string">"[.]"</span>;</span><br><span class="line">            <span class="keyword">else</span> ans += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/corporate-flight-bookings/description/" target="_blank" rel="noopener">1109. Corporate Flight Bookings</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：77.41%（268ms）</p><h3>题意</h3><p>有<code>n</code>条线段，每条线段有起止位置和权重，问所有线段加起来之后线上每个点的值。</p><h3>分析</h3><p>看起来像是线段树，不过只有加减操作，没有单次查询操作时其实并不需要线段树，用一个delta数组记录进入当前点时权值的变化就可以了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; corpFlightBookings(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">20005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(delta, <span class="number">0</span>, <span class="keyword">sizeof</span>(delta));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookings.size(); i++) &#123;</span><br><span class="line">            delta[bookings[i][<span class="number">0</span>]] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            delta[bookings[i][<span class="number">1</span>] + <span class="number">1</span>] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cur += delta[i];</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/delete-nodes-and-return-forest/description/" target="_blank" rel="noopener">1110. Delete Nodes And Return Forest</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：92.36%（20ms）</p><h3>题意</h3><p>给定一棵二叉树和一些要删除的结点，返回剩下的森林中的所有树的根结点。</p><h3>分析</h3><p>大体来说，一边DFS一边删就可以了。先处理左右子结点，然后检查当前结点是否需要被删除，如果是，则将左右子结点（如果存在）添加到森林的根列表中。同时还需要维护子结点指针的变化（因为有可能被删掉）。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp; delSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;left = dfs(root-&gt;left, delSet);</span><br><span class="line">        root-&gt;right = dfs(root-&gt;right, delSet);</span><br><span class="line">        <span class="keyword">if</span> (delSet.find(root-&gt;val) != delSet.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) ans.push_back(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) ans.push_back(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; delNodes(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; delSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: to_delete) delSet.insert(x);</span><br><span class="line">        root = dfs(root, delSet);</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) ans.push_back(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description/" target="_blank" rel="noopener">1111. Maximum Nesting Depth of Two Valid Parentheses Strings</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：100.00%（8ms）</p><h3>题意</h3><p>给定一个括号序列，需要把它分成两个子序列，使得这两个子序列的深度相差最少。</p><h3>分析</h3><p>最开始看到这题，我一脸懵逼，不知道该怎么做；后来看了<a href="https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC++Python-Several-Ideas" target="_blank" rel="noopener">别人的做法</a>，发现是非常简单的贪心。思路就是遍历这个括号序列，然后看情况把当前的括号分给其中一个子序列。为这两个子序列都维护当前深度（也就是还没有关闭的左括号的数目），使得这个深度尽量相等。至于为啥……啊，这个好难解释啊，不如意会一下吧……</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxDepthAfterSplit(<span class="built_in">string</span> seq) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">2</span>], depth[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">string</span> s[<span class="number">2</span>];</span><br><span class="line">        cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        depth[<span class="number">0</span>] = depth[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保持平均</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[<span class="number">0</span>] &lt; cnt[<span class="number">1</span>]) &#123;</span><br><span class="line">                    cnt[<span class="number">0</span>]++;</span><br><span class="line">                    ans.push_back(<span class="number">0</span>);</span><br><span class="line">                    s[<span class="number">0</span>] += c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt[<span class="number">1</span>]++;</span><br><span class="line">                    ans.push_back(<span class="number">1</span>);</span><br><span class="line">                    s[<span class="number">1</span>] += c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt; cnt[<span class="number">1</span>]) &#123;</span><br><span class="line">                    cnt[<span class="number">0</span>]--;</span><br><span class="line">                    ans.push_back(<span class="number">0</span>);</span><br><span class="line">                    s[<span class="number">0</span>] += c;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt[<span class="number">1</span>]--;</span><br><span class="line">                    ans.push_back(<span class="number">1</span>);</span><br><span class="line">                    s[<span class="number">1</span>] += c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth[<span class="number">0</span>] = max(depth[<span class="number">0</span>], cnt[<span class="number">0</span>]);</span><br><span class="line">            depth[<span class="number">1</span>] = max(depth[<span class="number">1</span>], cnt[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的题比较水，甚至都没有Hard的。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:String" scheme="https://zhanghuimeng.github.io/tags/alg-String/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
      <category term="alg:Binary Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 143总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-143/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-143/</id>
    <published>2019-06-30T13:13:52.000Z</published>
    <updated>2019-07-05T04:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的比赛倒是很简单。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/distribute-candies-to-people/description/" target="_blank" rel="noopener">1103. Distribute Candies to People</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>把<code>candies</code>颗糖分给<code>n</code>个人，依次分1，2，3……颗糖，从第1个人分到第n个人后，如果还没分完，继续从第一个人开始。问最后每个人各分了多少颗糖。</p><h3>分析</h3><p>这道题的思路很简单：首先计算出最多能完整地发几次糖，然后就可以列出公式计算每个人能得到的糖数了。当然，因为数据范围很小，另一种思路是直接暴力。</p><h3>代码</h3><p>不过，既然我都决定要暴力了，干吗还要算<code>n</code>……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">sqrt</span>(<span class="number">2</span> * candies);</span><br><span class="line">        <span class="keyword">while</span> (n * (n + <span class="number">1</span>) / <span class="number">2</span> &lt;= candies) n++;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(num_people, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans[(i - <span class="number">1</span>) % num_people] += i;</span><br><span class="line">            candies -= i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n % num_people] += candies;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/description/" target="_blank" rel="noopener">1104. Path In Zigzag Labelled Binary Tree</a></h2><p>标记难度：Easy</p><p>提交次数：2/3</p><p>代码效率：</p><ul><li>暴力方法：28ms</li><li>普通方法：0ms</li></ul><h3>题意</h3><p>给定一棵满二叉树，其中深度为奇数的层结点编号从左到右，深度为偶数的层结点编号从右到左，给定<code>label</code>，问根结点到该结点路径上经过的结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  3     2</span><br><span class="line"> / \   / \</span><br><span class="line">4   5 6   7</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3>分析</h3><p>最简单的思路是干脆把这棵树先建出来，然后模拟从<code>label</code>走到根的过程。比赛的时候我看到这道题一时心慌（感觉不大做得出来），于是就写了这种傻瓜做法，空间和时间复杂度都是<code>O(N)</code>。</p><p>当然，这种在树上走的题一般都可以做到时间复杂度<code>O(log(N))</code>（虽然此处没有实际的树）。虽然<code>label</code>在树中的位置相比正常的满二叉树发生了变化，不过它对应的层并没有变，所以可以首先计算出当前的层数，然后再换算每次上一层的label是什么。通过观察可以发现，无论本层是奇数层还是偶数层，公式都是一样的。</p><h3>代码</h3><h4>暴力方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathInZigZagTree(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">int</span> tree[<span class="number">1000005</span>];</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">pow</span> = <span class="number">1</span>, sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; sum &lt;= label; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = sum - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">pow</span>; j++) &#123;</span><br><span class="line">                    tree[sum] = last + j;</span><br><span class="line">                    <span class="keyword">if</span> (last + j == label) &#123;</span><br><span class="line">                        index = sum;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">pow</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                    tree[sum] = last + j;</span><br><span class="line">                    <span class="keyword">if</span> (last + j == label) &#123;</span><br><span class="line">                        index = sum;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">pow</span> *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(tree[index]);</span><br><span class="line">            index /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>普通方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathInZigZagTree(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; level) &lt;= label) level++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(label);</span><br><span class="line">            label = (<span class="number">1</span> &lt;&lt; level) - <span class="number">1</span> - (label - (<span class="number">1</span> &lt;&lt; (level<span class="number">-1</span>)));</span><br><span class="line">            label /= <span class="number">2</span>;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/filling-bookcase-shelves/description/" target="_blank" rel="noopener">1105. Filling Bookcase Shelves</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：28ms</p><h3>题意</h3><p>有若干本书，要求将这些书按顺序摆放在书架上：每次取出还没有摆完的编号最小的连续的且总宽度不超过书架宽度的几本书，摞到之前的层上，本层高度定为最高的书的高度，问把书摆完之后书架的最低高度。</p><h3>分析</h3><p>简单的DP题。用<code>f[i]</code>表示把第<code>[0..i]</code>本书放完时的最小高度，<code>g[i][j]</code>表示第<code>[i..j]</code>本书的总宽度，<code>h[i..j]</code>表示第<code>[i..j]</code>本书的最大高度。于是可以得到递推式<code>f[i] = min{f[j] + h[j+1..i]} (j &lt; i &amp;&amp; g[j+1..i] &lt; maxWidth)</code>，时间复杂度为<code>O(N^2)</code>。通过在DP过程中进行DP，<code>h</code>和<code>g</code>数组都可以省略，详见<a href="https://leetcode.com/problems/filling-bookcase-shelves/discuss/323315/Java-DP-solution" target="_blank" rel="noopener">Java DP solution</a>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> shelf_width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">1001</span>];  <span class="comment">// f[i]：把前i本书放完时的最小高度</span></span><br><span class="line">        <span class="keyword">int</span> g[<span class="number">1001</span>][<span class="number">1001</span>];  <span class="comment">// g[i][j]: books[i..j]的宽度（可以用前缀数组代替）</span></span><br><span class="line">        <span class="keyword">int</span> h[<span class="number">1001</span>][<span class="number">1001</span>];  <span class="comment">// h[i][j]: books[i..j]的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> n = books.size(), m = shelf_width;</span><br><span class="line">        <span class="comment">// books[i][0]是宽度，books[i][1]是高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = <span class="number">1e9</span>;</span><br><span class="line">            g[i][i] = books[i][<span class="number">0</span>];</span><br><span class="line">            h[i][i] = books[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                g[i][j] = g[i][j<span class="number">-1</span>] + books[j][<span class="number">0</span>];</span><br><span class="line">                h[i][j] = max(h[i][j<span class="number">-1</span>], books[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>] = books[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 一次把[j..i]都放了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[j][i] &gt; shelf_width) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> x = j == <span class="number">0</span> ? <span class="number">0</span> : f[j<span class="number">-1</span>];</span><br><span class="line">                f[i] = min(f[i], x + h[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/parsing-a-boolean-expression/description/" target="_blank" rel="noopener">1106. Parsing A Boolean Expression</a></h2><p>标记难度：Hard</p><p>提交次数：1/2</p><p>代码效率：28ms</p><h3>题意</h3><p>给定一个布尔表达式，求值。</p><h3>分析</h3><p>和上周的<a href="https://leetcode.com/problems/brace-expansion-ii" target="_blank" rel="noopener">1096. Brace Expansion II</a>挺像的，但是要简单一些。直接用一个栈模拟就行了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parseBoolExpr</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: expression) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.back() != <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stk.back() == <span class="string">'t'</span>) a.push_back(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (stk.back() == <span class="string">'f'</span>) a.push_back(<span class="literal">false</span>);</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop_back(); <span class="comment">// (</span></span><br><span class="line">                <span class="keyword">char</span> type = stk.back();</span><br><span class="line">                stk.pop_back();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">bool</span> f = a[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="string">'!'</span>) f = !a[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.size(); i++)</span><br><span class="line">                        f = type == <span class="string">'|'</span> ? (f || a[i]) : (f &amp;&amp; a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push_back(f == <span class="literal">true</span> ? <span class="string">'t'</span> : <span class="string">'f'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ans = stk.back();</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="string">'t'</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的比赛倒是很简单。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="alg:Stack" scheme="https://zhanghuimeng.github.io/tags/alg-Stack/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 142总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-142/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-142/</id>
    <published>2019-06-23T20:48:34.000Z</published>
    <updated>2019-06-24T11:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的最后一道题简直做到脑壳疼。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/statistics-from-a-large-sample/description/" target="_blank" rel="noopener">1093. Statistics from a Large Sample</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>用类似哈希表的方式给定一堆数字，求它们的最小值、最大值、平均值、中位数和众数。</p><h3>分析</h3><p>这下我学到了，“mode”是众数的意思。</p><p>……除了中位数之外，其他统计值都没有什么难的。当然，中位数也不难，先计算数字的总数，然后数出位于中间的1/2个数即可。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.size(); i++) &#123;</span><br><span class="line">            sum += count[i];</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= sum) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sampleStats(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; count) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = count.size(), cnt = <span class="number">0</span>, modeIdx = <span class="number">0</span>, sum = <span class="number">0</span>, minn = <span class="number">-1</span>, maxn = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt += count[i];</span><br><span class="line">            sum += i * count[i];</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; count[modeIdx]) modeIdx = i;</span><br><span class="line">            <span class="keyword">if</span> (minn == <span class="number">-1</span> &amp;&amp; count[i] &gt; <span class="number">0</span>) minn = i;</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) maxn = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> median;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) median = (getKth(cnt / <span class="number">2</span>, count) + getKth(cnt / <span class="number">2</span> + <span class="number">1</span>, count)) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">else</span> median = getKth(cnt / <span class="number">2</span> + <span class="number">1</span>, count);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;minn, maxn, (<span class="keyword">double</span>) sum / cnt, median, modeIdx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/car-pooling/description/" target="_blank" rel="noopener">1094. Car Pooling</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：8ms</p><h3>题意</h3><p>给定一辆车的容量和若干批游客的数量、上车地点、下车地点，求这辆车能否载动这批游客。</p><h3>分析</h3><p>因为总站数很少，所以只需计算出每一站净上车的人数，然后模拟，就可以知道是否会出现超载的情况了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> peopleCnt[<span class="number">1001</span>];</span><br><span class="line">        <span class="built_in">memset</span>(peopleCnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(peopleCnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trips.size(); i++) &#123;</span><br><span class="line">            peopleCnt[trips[i][<span class="number">1</span>]] += trips[i][<span class="number">0</span>];</span><br><span class="line">            peopleCnt[trips[i][<span class="number">2</span>]] -= trips[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            cnt += peopleCnt[i];</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/find-in-mountain-array/description/" target="_blank" rel="noopener">1095. Find in Mountain Array</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：8ms</p><h3>题意</h3><p>给定一个先单增再单减的数组，要求从中找出<code>target</code>出现的位置，如果没有则返回-1。要求查询数组元素的次数小于100次。</p><h3>分析</h3><p>先用三分查找找到峰的位置，再分别做两次二分查找，一次在峰左边单增的部分，一次在右边单减的部分。想了想，好像还是没有办法直接用三分查找的思路一次把这个数找出来……</p><p>二分查找一如既往写得乱七八糟，最后仍然只好用了判断<code>l</code>和<code>l+1</code>的策略。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = mountainArr.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> m2 = l + (r - l) / <span class="number">3</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> x1 = mountainArr.get(m1), x2 = mountainArr.get(m2);</span><br><span class="line">            <span class="keyword">if</span> (x1 &lt; x2) l = m1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m2 - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = l, maxn = mountainArr.get(l);</span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; mountainArr.get(l + <span class="number">1</span>) &gt; maxn) &#123;</span><br><span class="line">            maxIdx++;</span><br><span class="line">            maxn = mountainArr.get(maxIdx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == maxn) <span class="keyword">return</span> maxIdx;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; maxn) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span>, r = maxIdx;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> x = mountainArr.get(m);</span><br><span class="line">            <span class="keyword">if</span> (target &lt; x) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        l = maxIdx + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> x = mountainArr.get(m);</span><br><span class="line">            <span class="keyword">if</span> (target &lt; x) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; target) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/brace-expansion-ii/description/" target="_blank" rel="noopener">1096. Brace Expansion II</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：20ms</p><h3>题意</h3><p>给定下列文法，求该文法表示的词的集合（注意去重）：</p><ul><li>单字符是合法的表达式：<code>&quot;a&quot;</code></li><li>若干个表示连接起来是合法的表达式：<code>&quot;a{b}c&quot;</code></li><li>若干个表达式用<code>,</code>连接，外加<code>{}</code>，是合法的表达式：<code>&quot;{ {a,b},c&quot;}</code></li><li>单字符表达式表示一个仅包含该字符的集合：<code>R(&quot;a&quot;) = {&quot;a&quot;}</code></li><li>大括号中用<code>,</code>隔开的表达式表示由所有被隔开的表达式组成的集合：<code>R(&quot;{a,b,c}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}</code></li><li>若干个表达式不加<code>,</code>连接起来组成的表达式表示这些表达式的笛卡尔积：<code>R(&quot;{a,b}{c,d}&quot;) = {&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;}</code></li></ul><p>（这里双大括号在Hexo解析里仍然有问题，只好中间加个空格了。）</p><h3>分析</h3><p>（看到这种题不由得想起编译原理中创造的Decaf语言，然而我已经有点忘了EBNF文法怎么写了）</p><p>本来打算用栈写，后来发现写成递归函数好弄得多，所以就递归函数了。</p><p>这个文法在代码中解码的方法很多（不过它起码是无二义的……是吧），最后我在代码里写出来的结果是：</p><ul><li>首先判断是否为纯字母</li><li>然后判断是否为表达式的乘积</li><li>最后判断是否为表达式的连接</li></ul><p>判断为纯字母而不是判断为<strong>单个</strong>字母的表面原因是节省递归深度，实际原因是按我的写法，没法直接判断纯字母串是否为表达式的乘积。判断字符串是否为表达式的连接比较简单，只要看是否字符串前后都是大括号而且这两个括号成一对就可以了，然后把这对大括号中不在其他大括号内的逗号拆掉；而把表达式乘积字符串拆开比较难，需要分外层的字母和外层的大括号两种情况讨论。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; braceExpansionII(<span class="built_in">string</span> expression) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isAlpha = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: expression)</span><br><span class="line">            <span class="keyword">if</span> (ch &lt; <span class="string">'a'</span> || ch &gt; <span class="string">'z'</span>) &#123;</span><br><span class="line">                isAlpha = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (isAlpha) <span class="keyword">return</span> &#123;expression&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试展开为表达式的乘积</span></span><br><span class="line">        <span class="keyword">int</span> paren = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expression[i] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (paren == <span class="number">0</span> &amp;&amp; !(!e.empty() &amp;&amp; e.back().size() == <span class="number">0</span>)) e.push_back(expression.substr(i, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> e.back() += expression[i];</span><br><span class="line">                paren++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (expression[i] == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                paren--;</span><br><span class="line">                e.back() += expression[i];</span><br><span class="line">                <span class="keyword">if</span> (paren == <span class="number">0</span>) e.push_back(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.empty()) e.push_back(expression.substr(i, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> e.back() += expression[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!e.empty() &amp;&amp; e.back().size() == <span class="number">0</span>) e.pop_back();</span><br><span class="line">        <span class="keyword">if</span> (e.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v, v1, v2;</span><br><span class="line">            v = braceExpansionII(e[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; e.size(); i++) &#123;</span><br><span class="line">                v1 = braceExpansionII(e[i]);</span><br><span class="line">                v2.clear();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">string</span> s1: v)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">string</span> s2: v1)</span><br><span class="line">                        v2.push_back(s1 + s2);</span><br><span class="line">                v = v2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; sset;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> s: v) sset.insert(s);</span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> s: sset) v.push_back(s);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试展开为表达式的连接</span></span><br><span class="line">        e.clear();</span><br><span class="line">        expression = expression.substr(<span class="number">1</span>, expression.length() - <span class="number">2</span>);</span><br><span class="line">        paren = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expression[i] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.empty()) e.push_back(expression.substr(i, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> e.back() += expression[i];</span><br><span class="line">                paren++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (expression[i] == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                e.back() += expression[i];</span><br><span class="line">                paren--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (expression[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (paren == <span class="number">0</span>) e.push_back(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">else</span> e.back() += expression[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.empty()) e.push_back(expression.substr(i, <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> e.back() += expression[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: e) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1(braceExpansionII(s));</span><br><span class="line">            v.insert(v.end(), v1.begin(), v1.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; sset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s: v) sset.insert(s);</span><br><span class="line">        v.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s: sset) v.push_back(s);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的最后一道题简直做到脑壳疼。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Binary Search" scheme="https://zhanghuimeng.github.io/tags/alg-Binary-Search/"/>
    
      <category term="alg:Ternary Search" scheme="https://zhanghuimeng.github.io/tags/alg-Ternary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #567 Div.2 D. Irrigation总结（Treap）</title>
    <link href="https://zhanghuimeng.github.io/post/codeforces-round-567-div-2-d-irrigation/"/>
    <id>https://zhanghuimeng.github.io/post/codeforces-round-567-div-2-d-irrigation/</id>
    <published>2019-06-22T09:41:28.000Z</published>
    <updated>2019-06-23T12:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来为了节省时间，决定之后不再写CF比赛的总结（要不然得写到天荒地老），但是这道题折磨了我一天多的时间，最后甚至连对拍器都写出来了，所以值得一写，顺便也总结一下Treap……</p><p>题目链接：<a href="https://codeforces.com/contest/1181/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1181/problem/D</a></p><a id="more"></a><h3>题意</h3><p>有<code>m</code>个城市要轮流举办奥运会，按举办次数从小到大且编号从小到大的顺序，之前奥运会已经举办过了<code>n</code>次。给定<code>q</code>个询问，问这些年份分别是哪些城市举办奥运会。</p><h3>分析</h3><h4>解法1：名次树</h4><p>考虑一下实际举办的情况，很容易想到一种这样的算法：首先把所有城市按举办次数为第一关键字，编号为第二关键字排序，然后每次取第一个城市为下一年举办奥运会的城市，取完之后更新举办次数，重新排序；等到各城市举办次数都一样之后，就只是按编号顺序继续举办了。当然，直接这么做肯定会超时。</p><p>继续观察可以发现，如果前面有几个城市的举办次数都相同，那么它们会轮流举办，直到每个城市的举办次数都达到之后的举办次数更多的城市为止。下面是<a href="https://codeforces.com/blog/entry/67727" target="_blank" rel="noopener">题解</a>里的图：</p><p><img src="cities.png" alt="顺序示意图"></p><p>首先城市3会举办一次。之后，2、3、5的举办次数就相等了，会按2、3、5的顺序各举办一次。这之后，1、2、3、5、8的举办次数就相等了，会按1、2、3、5、8的顺序举办两次……</p><p>这样解题思路就很清楚了。首先把城市排序，查询也排序；然后对于每个查询，判断它位于哪两个举办次数的区间中，然后把之前的年份都加到一个名次树中，根据查询的具体大小计算它应该轮到第几个城市，最后在名次树里查询就可以了。</p><p>结果问题出在了名次树上。我从网上找了一个<a href="https://zhuanlan.zhihu.com/p/26003598" target="_blank" rel="noopener">Treap模板</a>，结果总是在Test 15超时，最后把这个Treap模板和其他模板对比，发现这个模板的插入操作写挂了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* &amp;o,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!o) &#123;</span><br><span class="line">o = <span class="keyword">new</span> Node(v);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> d = o -&gt; cmp(v);</span><br><span class="line"><span class="keyword">if</span>(d == <span class="number">-1</span>) o -&gt; w++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">insert(o -&gt; ch[d], v);</span><br><span class="line">            <span class="comment">// 这里变成指针比较了，而不是rank比较</span></span><br><span class="line"><span class="keyword">if</span>(o -&gt; ch[d] &gt; o) rotate(o, d^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">o-&gt;maintain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，经过我漫长的对拍，似乎这个写法并不是错的，只会影响效率（大概这也是为什么原作者没发现）。但是查了半天，都说这样的指针比较是未被定义的，所以如果不认真看看代码，恐怕并不知道为什么这样不是错的……</p><h3>解法2：一种不需要名次树的方法</h3><p>这种方法的思路是这样的：想象一个宽度为<code>M</code>，高度无限的矩形，每年在矩形中的一个格子上着色，按从左到右，从下向上的顺序。着色的列表示当年举办奥运会的城市，即在第<code>T</code>年，会对第<code>T % M</code>列染色。现在的问题是，已经有<code>N</code>个城市举办过比赛了；在这种情况下，仍然可以顺序染色，只要把举办过比赛的城市跳过去就行。</p><p>把这种方法和上一种对比，会发现实际效果是相同的：在举办次数较少的城市的举办次数没有超过举办次数更多的城市之前，一直在那些举办次数较少的城市之间轮流举行。问题是怎么确定跳过哪些城市。以题目中的Example 1为例，第7到16年的奥运会是这样举办的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| 13 | 14 | 15 | 16 |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| *  | 10 | 11 | 12 |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| *  | *  | 8  | 9  |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| *  | *  | *  | 7  |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">  1    2    3    4</span><br></pre></td></tr></table></figure><p>为了快速找到年份对应的格子，不妨在为<code>*</code>号的格子里也填上数字，具体的数字是下一个年份-1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+----+----+----+</span><br><span class="line">| 13 | 14 | 15 | 16 |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| 9  | 10 | 11 | 12 |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| 7  | 7  | 8  | 9  |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| 6  | 6  | 6  | 7  |</span><br><span class="line">+----+----+----+----+</span><br><span class="line">  1    2    3    4</span><br></pre></td></tr></table></figure><p>填上的数字为<code>[6, 6, 6, 7, 7, 9]</code>。于是，对于每一个查询的年份，只要二分查找一共有多少个填充的数字比它小，就可以知道一共跳过了多少个城市，然后就可以计算出这一年应该在哪个城市举办奥运会了。</p><h2>代码</h2><p>解法1：<a href="https://codeforces.com/contest/1181/submission/55874889" target="_blank" rel="noopener">https://codeforces.com/contest/1181/submission/55874889</a></p><p>解法2：<a href="https://codeforces.com/contest/1181/submission/55650482" target="_blank" rel="noopener">https://codeforces.com/contest/1181/submission/55650482</a></p><h2>对拍器</h2><p>这里为了方便起见，干脆把Windows版的脚本对拍器贴出来。当然，如果有朝一日非得对拍而又没有网的话，写个管道+C++对拍器可能更简单。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:loop</span><br><span class="line">    gen</span><br><span class="line">    <span class="built_in">echo</span> New data generated</span><br><span class="line">    std &lt; a.<span class="keyword">in</span> &gt; std.out</span><br><span class="line">    <span class="built_in">echo</span> Std executed</span><br><span class="line">    a &lt; a.<span class="keyword">in</span> &gt; a.out</span><br><span class="line">    <span class="built_in">echo</span> Program executed</span><br><span class="line">    fc /a a.out std.out</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">errorlevel</span> <span class="number">1</span> <span class="built_in">pause</span></span><br><span class="line">    <span class="built_in">echo</span> test finished</span><br><span class="line"><span class="keyword">goto</span> loop</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来为了节省时间，决定之后不再写CF比赛的总结（要不然得写到天荒地老），但是这道题折磨了我一天多的时间，最后甚至连对拍器都写出来了，所以值得一写，顺便也总结一下Treap……&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1181/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1181/problem/D&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/categories/Codeforces/"/>
    
    
      <category term="Codeforces" scheme="https://zhanghuimeng.github.io/tags/Codeforces/"/>
    
      <category term="Codeforces Contest" scheme="https://zhanghuimeng.github.io/tags/Codeforces-Contest/"/>
    
      <category term="alg:Rank Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Rank-Tree/"/>
    
      <category term="alg:Treap" scheme="https://zhanghuimeng.github.io/tags/alg-Treap/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 141总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-141/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-141/</id>
    <published>2019-06-17T09:44:34.000Z</published>
    <updated>2019-06-21T19:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的比赛还是挺难的。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/duplicate-zeros/description/" target="_blank" rel="noopener">1089. Duplicate Zeros</a></h2><p>标记难度：Easy</p><p>提交次数：1/3</p><p>代码效率：30.21%（28ms）</p><h3>题意</h3><p>给定一个数组，把其中的0都在原位增加成两个，然后把数组截取到原来的长度。问能否在<code>O(1)</code>空间复杂度内完成这一操作。</p><h3>分析</h3><p>如果没有空间复杂度的要求，这道题非常简单：直接新开一个数组存变换后的数组，然后再截回去。但现在显然不能这么做。如何不增加额外空间呢？在0增加而数组长度不变的要求下，数组中总的有效元素数量实际上减少了，也就是原来位于数组尾部的那些元素被丢掉了；只需要把将会留下来的元素按照一定顺序放到空出来的位置即可。在下面这个例子中，将要被丢掉的两个元素是5和0。4原来的位置上将要放0，但是不能直接把0放过去，因为会覆盖掉4；所以应该从右向左逐步向右边空出来的位置上移动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        1 0 2 3 0 4 5 0</span><br><span class="line">        1 0 0 2 3 0 0 4 5 0 0</span><br><span class="line"></span><br><span class="line">move 4: 1 0 2 3 0 ? 5 4</span><br><span class="line">move 0: 1 0 2 3 ? 0 0 4</span><br><span class="line">move 3: 1 0 2 ? 3 0 0 4</span><br><span class="line">move 2: 1 0 ? 2 3 0 0 4</span><br><span class="line">move 0: 1 0 0 2 3 0 0 4</span><br><span class="line">move 1: 1 0 0 2 3 0 0 4</span><br></pre></td></tr></table></figure><p>为了找到正确的移动位置，只需知道当前的数字前面有多少个0，所以我们在代码中先从前往后扫描一遍计算出0的总数，再从后往前，一遍移动元素，一边更新前面还有多少个0。时间复杂度是<code>O(N)</code>。</p><p>不过这么一来，难度怎么看也不像Easy了……</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeroCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != <span class="number">0</span> &amp;&amp; i + zeroCnt &gt;= n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + zeroCnt + <span class="number">1</span> &gt;= n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span>)</span><br><span class="line">                zeroCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != <span class="number">0</span> &amp;&amp; i + zeroCnt &lt; n)</span><br><span class="line">                arr[i + zeroCnt] = arr[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + zeroCnt &lt; n)</span><br><span class="line">                    arr[i + zeroCnt] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + zeroCnt + <span class="number">1</span> &lt; n)</span><br><span class="line">                    arr[i + zeroCnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                zeroCnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/largest-values-from-labels/description/" target="_blank" rel="noopener">1090. Largest Values From Labels</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：27.26%（48ms）</p><h3>题意</h3><p>给定一个集合，其中的每个元素都有一个标签，要求从中选出一个子集，满足子集大小<code>&lt;=num_wanted</code>，每种标签对应的元素总数<code>&lt;=use_limit</code>，且子集的和最大。</p><h3>分析</h3><p>这道题倒是很简单的数据结构应用题。直接从每个标签对应的元素中选出前<code>use_limit</code>大的元素，再从这些元素里选出前<code>num_wanted</code>即可。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestValsFromLabels</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; labels, <span class="keyword">int</span> num_wanted, <span class="keyword">int</span> use_limit)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; labelMap;</span><br><span class="line">        <span class="keyword">int</span> n = values.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            labelMap[labels[i]].push_back(values[i]);</span><br><span class="line">        <span class="comment">// 当时大概脑抽了才用了优先队列</span></span><br><span class="line">        <span class="comment">// 实际上排序就够了</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: labelMap) &#123;</span><br><span class="line">            sort(p.second.begin(), p.second.end());</span><br><span class="line">            <span class="keyword">int</span> m = p.second.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; use_limit &amp;&amp; i &lt; m; i++)</span><br><span class="line">                pq.push(p.second[m - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_wanted &amp;&amp; !pq.empty(); i++) &#123;</span><br><span class="line">            ans += pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/description/" target="_blank" rel="noopener">1091. Shortest Path in Binary Matrix</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：40.84%（68ms）</p><h3>题意</h3><p>求一个八连通方格图从左上角到右下角的最短路，图中有若干障碍物。</p><h3>分析</h3><p>直接BFS即可。</p><p>（本次比赛的前三题难度似乎是递减的。）</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mx[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>,  <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> my[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        q.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front().first, y = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == m - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> dist[x][y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + mx[i], ny = y + my[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny] &amp;&amp; grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                    visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                    dist[nx][ny] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">                    q.emplace(nx, ny);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/shortest-common-supersequence/description/" target="_blank" rel="noopener">1092. Shortest Common Supersequence</a></h2><p>标记难度：Hard</p><p>提交次数：2/6</p><p>代码效率：</p><ul><li>普通的写法：35.22%（52ms）</li><li>更好的写法：0.00%（624ms）</li></ul><h3>题意</h3><p>给定两个字符串，返回任意一个最短的同时以这两个字符串为子串的字符串。</p><h3>分析</h3><p>这道题本质上是要求两个字符串的最长公共子串，求出来之后，对于公共子串的每两个字符，把两个字符串中这两个字符之间的字符都塞到公共子串里面去就行了。问题在于如何求最长公共子串。</p><p>一种比较省空间的方法是，记录动态规划过程中每一步的计算过程，然后在得到最优解之后回溯。这样做的缺点是比较难写……至少我是这样觉得的，我似乎写了很久。而一种更容易写的方法是，直接在动态规划过程中记录当前的最长公共子串。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h3>代码</h3><h4>普通的写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestCommonSupersequence</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">        <span class="keyword">int</span> last[<span class="number">1005</span>][<span class="number">1005</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> n = str1.length(), m = str2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">                last[i][j][<span class="number">0</span>] = last[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 因为是从0开始的，所以比较麻烦</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; f[i<span class="number">-1</span>][j] &gt;= f[i][j]) &#123;</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">                    last[i][j][<span class="number">0</span>] = <span class="number">-1</span>, last[i][j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; f[i][j<span class="number">-1</span>] &gt;= f[i][j]) &#123;</span><br><span class="line">                    f[i][j] = f[i][j<span class="number">-1</span>];</span><br><span class="line">                    last[i][j][<span class="number">0</span>] = <span class="number">0</span>, last[i][j][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &gt; f[i][j]) &#123;</span><br><span class="line">                        f[i][j] = <span class="number">1</span>;</span><br><span class="line">                        last[i][j][<span class="number">0</span>] = <span class="number">-1</span>, last[i][j][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span> &gt;= f[i][j]) &#123;</span><br><span class="line">                        f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                        last[i][j][<span class="number">0</span>] = <span class="number">-1</span>, last[i][j][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>, j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; !(last[i][j][<span class="number">0</span>] == <span class="number">-1</span> &amp;&amp; last[i][j][<span class="number">1</span>] == <span class="number">-1</span>) &amp;&amp; !(last[i][j][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; last[i][j][<span class="number">1</span>] == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (last[i][j][<span class="number">0</span>] == <span class="number">-1</span>)</span><br><span class="line">                    ans = str1[i] + ans;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans = str2[j] + ans;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> t = last[i][j][<span class="number">1</span>];</span><br><span class="line">                i += last[i][j][<span class="number">0</span>], j += t;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; last[i][j][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; last[i][j][<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; last[i][j][<span class="number">0</span>] == <span class="number">-1</span> &amp;&amp; last[i][j][<span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = str1[i] + ans;</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) ans = str1.substr(<span class="number">0</span>, i + <span class="number">1</span>) + ans;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) ans = str2.substr(<span class="number">0</span>, j + <span class="number">1</span>) + ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>更好的写法</h4><p>大概因为字符串处理太多，这种方法慢得可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestCommonSupersequence</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">int</span> n = str1.length(), m = str2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 这是一种解决index问题的方法</span></span><br><span class="line">                <span class="keyword">if</span> (str1[i] == str2[j])</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = f[i][j] + str1[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = f[i][j+<span class="number">1</span>].length() &gt; f[i+<span class="number">1</span>][j].length() ? f[i][j+<span class="number">1</span>] : f[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = f[n][m];</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m &amp;&amp; k &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (str1[i] != s[k] &amp;&amp; i &lt; n) &#123;</span><br><span class="line">                ans += str1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (str2[j] != s[k] &amp;&amp; j &lt; m) &#123;</span><br><span class="line">                ans += str2[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += s[k];</span><br><span class="line">            i++, j++, k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原来substr还有单变量的版本……</span></span><br><span class="line">        <span class="comment">// http://www.cplusplus.com/reference/string/string/substr/</span></span><br><span class="line">        ans += str1.substr(i) + str2.substr(j);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/shortest-common-supersequence/discuss/312710/C++Python-Find-the-LCS" target="_blank" rel="noopener">lee215's Solution for Leetcode 1092 - [C++/Python] Find the LCS</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的比赛还是挺难的。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
      <category term="alg:Breadth-first Search" scheme="https://zhanghuimeng.github.io/tags/alg-Breadth-first-Search/"/>
    
      <category term="alg:Sort" scheme="https://zhanghuimeng.github.io/tags/alg-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 140总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-140/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-140/</id>
    <published>2019-06-11T18:50:28.000Z</published>
    <updated>2019-06-13T18:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周的比赛内容可以说是有点诡异。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/occurrences-after-bigram/description/" target="_blank" rel="noopener">1078. Occurrences After Bigram</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>给定一个用空格分隔的字符串和两个词，找出字符串中所有连续出现这两个词时后面跟着的第三个词。</p><h3>分析</h3><p>虽然题目描述听起来有些怪异，但搞明白之后，原理还是非常简单的；唯一的问题可能还是，C++不自带字符串split功能……</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">const</span> <span class="built_in">string</span>&amp; delim)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">        <span class="keyword">size_t</span> prev = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = str.find(delim, prev);</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="built_in">string</span>::npos) pos = str.length();</span><br><span class="line">            <span class="built_in">string</span> token = str.substr(prev, pos-prev);</span><br><span class="line">            <span class="keyword">if</span> (!token.empty()) tokens.push_back(token);</span><br><span class="line">            prev = pos + delim.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; str.length() &amp;&amp; prev &lt; str.length());</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findOcurrences(<span class="built_in">string</span> text, <span class="built_in">string</span> first, <span class="built_in">string</span> second) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = split(text, <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; words[i<span class="number">-1</span>] == first &amp;&amp; words[i] == second)</span><br><span class="line">                ans.push_back(words[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/letter-tile-possibilities/description/" target="_blank" rel="noopener">1079. Letter Tile Possibilities</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：</p><ul><li>DFS：44.36%（64ms）</li><li>数学：0ms</li></ul><h3>题意</h3><p>给定7个大写字母，问用这些字母最多能组成多少种不同的非空序列。</p><h3>分析</h3><p>在数据大小只有7的前提下，我猜怎么做都可以，于是我就直接DFS枚举去重了，时间也没有很慢。</p><p>当然，稍微好一点的思路是先考虑选择每种字母各多少个，选好之后，再考虑将这些字母排列之后能够产生多少种序列。假定<code>cnt[i]</code>表示第<code>i</code>个字母的数量，则选择字母的总方案数为<code>(cnt[0] + 1) * (cnt[1] + 1) * ... * (cnt[25] + 1)</code>（+1是因为可以不选）；选好之后，排列总数为</p><p>$$<br>\frac{(\sum_{i=0}^{25} cnt'[i])!}{\prod_{i=0}^{25} cnt'[i]!}<br>$$</p><p>（显然，这是基础的组合数学知识）</p><p>一种我比较喜欢的解法<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>在此处采用了一种很聪明的写法：直接用类似于进制转换的方法枚举出每种字母选了多少个（而不是用DFS再穷举）。</p><h3>代码</h3><h4>DFS</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; seqs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt, <span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">        seqs.insert(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                dfs(cnt, x + (<span class="keyword">char</span>) (<span class="string">'A'</span> + i));</span><br><span class="line">                cnt[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: tiles)</span><br><span class="line">            cnt[c - <span class="string">'A'</span>]++;</span><br><span class="line">        dfs(cnt, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> seqs.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>数学</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            p *= x--;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: tiles)</span><br><span class="line">            cnt[ch - <span class="string">'A'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            f *= cnt[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> freq[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; f; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                freq[j] = x % (cnt[j] + <span class="number">1</span>);</span><br><span class="line">                sum += freq[j];</span><br><span class="line">                x /= cnt[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = fac(sum);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">                sum /= fac(freq[j]);</span><br><span class="line">            ans += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/description/" target="_blank" rel="noopener">1080. Insufficient Nodes in Root to Leaf Paths</a></h2><p>标记难度：Medium</p><p>提交次数：1/5</p><p>代码效率：81.63%（44ms）</p><h3>题意</h3><p>给定一棵二叉树，同时从树上删去所有满足以下条件的结点：所有经过该结点的从根到叶子的路径上结点值的总和均小于<code>limit</code>。</p><h3>分析</h3><p>这道题的描述可真是太绕了。首先可以发现一个事实：因为所有经过孩子的路径必然会经过父亲，所以如果父亲不合法，孩子必然也不合法，最后并不会删出来孤儿结点之类的（虽然这个事实没什么用）。下一个问题就是怎么合理地把这些描述塞到一次对树的遍历中了。</p><ul><li>因为需要求路径上结点的和，所以需要加一个<code>sum</code>参数</li><li>因为需要删除结点，所以需要返回一个指针，不删除时将当前结点返回，如果删除则返回<code>NULL</code></li><li>因为只有在底层遍历结束时才能够知道路径的和，所以需要在发现是叶子结点时返回路径的和</li><li>……</li></ul><p>因为C++并不能返回Tuple，所以最后只好把一些内容塞到了传引用的参数里。</p><p>最后需要注意的一点是（因为我用的是C++），删除结点之后不要自己把它delete掉，否则会RE，大概Leetcode内部自己delete过了……</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sum：到root为止的sum</span></span><br><span class="line">    <span class="comment">// faMaxSum：经过父结点的路径的最大sum</span></span><br><span class="line">    <span class="comment">// myMaxSum：经过当前结点的路径的最大sum</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> limit, <span class="keyword">int</span> sum, <span class="keyword">int</span>&amp; faMaxSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> myMaxSum = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="comment">// 在删除结点之前判断是否为叶子</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            myMaxSum = max(myMaxSum, sum);</span><br><span class="line">        root-&gt;left = dfs(root-&gt;left, limit, sum, myMaxSum);</span><br><span class="line">        root-&gt;right = dfs(root-&gt;right, limit, sum, myMaxSum);</span><br><span class="line">    </span><br><span class="line">        faMaxSum = max(faMaxSum, myMaxSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (myMaxSum &lt; limit)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, limit, <span class="number">0</span>, maxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/" target="_blank" rel="noopener">1081. Smallest Subsequence of Distinct Characters</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：</p><ul><li>O(N^2)：22.33%（8ms）</li><li>栈：0ms</li></ul><h3>题意</h3><p>给定一个字符串，要求从中选择满足以下条件且字典序最小的子序列：包含原串中每个字母一次，且仅包含一次。</p><h3>分析</h3><p>我开始的时候随便脑补了一种做法：</p><ul><li>从右到左遍历字符串，记录满足以下条件中对应的字母最小且最靠左的index：从index开始的后缀中已经包含了原串中的所有字母</li><li>记录index对应的字母，把index左侧的字符串丢掉，在index右侧的字符串中也去除该字母</li><li>回到第一步，直到字符串为空为止</li></ul><p>这是一种贪心的做法。在这种做法中，每次选择的都是“下一个字母”，所以为了使字典序最小，需要选择“能够选的字母中最小的”。显然，只有对应后缀中仍然包含所有剩余字母的字母可以选；在较小的字母中仍然选择靠左的是因为这样右侧剩下的字母会多一些。</p><p>当然，这么做不够好。更好的做法是用一个栈来存储结果：如果下一个字母比当前栈底要小，且之后栈底字母还会再次出现，则可以把栈底弹出。这样做更像是在尝试寻找一个单调递增的序列，虽然很显然不一定能找到。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h3>代码</h3><h4>O(N^2)的贪心</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (!text.empty()) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; chSet;</span><br><span class="line">            <span class="keyword">int</span> maxCnt = <span class="number">0</span>, minPos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">char</span> minChar = <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = text.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                chSet.insert(text[i]);</span><br><span class="line">                <span class="keyword">if</span> (chSet.size() &gt; maxCnt || text[i] &lt;= minChar) &#123;</span><br><span class="line">                    maxCnt = chSet.size();</span><br><span class="line">                    minChar = text[i];</span><br><span class="line">                    minPos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 丢掉左边的部分</span></span><br><span class="line">            text = text.substr(minPos + <span class="number">1</span>, text.size() - minPos - <span class="number">1</span>);</span><br><span class="line">            ans += minChar;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="comment">// 在右边去掉所有minChar</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: text)</span><br><span class="line">                <span class="keyword">if</span> (ch != minChar)</span><br><span class="line">                    tmp += ch;</span><br><span class="line">            text = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: text)</span><br><span class="line">            cnt[c - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">bool</span> visited[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: text) &#123;</span><br><span class="line">            cnt[c - <span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (visited[c - <span class="string">'a'</span>]) <span class="keyword">continue</span>; <span class="comment">// 为了保证结果，这是必要的</span></span><br><span class="line">            <span class="keyword">while</span> (!ans.empty() &amp;&amp; ans.back() &gt; c &amp;&amp; cnt[ans.back() - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                visited[ans.back() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(c);</span><br><span class="line">            visited[c - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/letter-tile-possibilities/discuss/308216/Simple-Python-solution-with-thinking-process-(works-for-much-longer-input)" target="_blank" rel="noopener">Simple Python solution with thinking process (works for much longer input)</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/discuss/308210/JavaPython-Stack-Solution-O%28N%29" target="_blank" rel="noopener">lee215's Solution for Leetcode 1081 - [Java/Python] Stack Solution O(N)</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周的比赛内容可以说是有点诡异。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Tree" scheme="https://zhanghuimeng.github.io/tags/alg-Tree/"/>
    
      <category term="alg:Math" scheme="https://zhanghuimeng.github.io/tags/alg-Math/"/>
    
      <category term="alg:String" scheme="https://zhanghuimeng.github.io/tags/alg-String/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
      <category term="alg:Stack" scheme="https://zhanghuimeng.github.io/tags/alg-Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 139总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-139/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-139/</id>
    <published>2019-06-03T03:55:02.000Z</published>
    <updated>2019-06-04T02:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次还是比较简单的。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/greatest-common-divisor-of-strings/description/" target="_blank" rel="noopener">1071. Greatest Common Divisor of Strings</a></h2><p>标记难度：Easy</p><p>提交次数：3/3</p><p>代码效率：</p><ul><li>暴力：26.03%（12ms）</li><li>gcd：95.04%（4ms）</li></ul><h3>题意</h3><p>求两个字符串的“最大公约字符串”。</p><h3>分析</h3><p>以这道题的数据规模（字符串长度为1000），最暴力的方法就能过了：对于第二个字符串的每一个子串，判断它能否整除第一个子串。显然我们可以只选择长度为第一个字符串的约束的子串，所以实际的时间复杂度并不大。另一个优化方法是从最长的子串开始，找到最长的子串就返回，这样可以避免重复。</p><p>当然，更好的方法是模拟数字的gcd计算字符串的gcd。具体的方法并不完全一样（显然，不太好对字符串求余数），但一种实现方法是，每次只检查长度较短的字符串是否是另一个字符串的前缀，如果是，则继续检查该字符串和另一个字符串去掉前缀之后的结果；否则gcd为空。当较短字符串为空时，较长的字符串就是gcd。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h3>代码</h3><h4>暴力</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span>&amp; T, <span class="built_in">string</span>&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T.length() % x.length() != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> N = T.length(), n = x.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T.substr(i, n) != x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length(), m = T.length();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(n, m); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> x = S.substr(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (check(S, x) &amp;&amp; check(T, x))</span><br><span class="line">                maxLen = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S.substr(<span class="number">0</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3>gcd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str1.length(), n = str2.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> str1;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> gcdOfStrings(str2, str1);</span><br><span class="line">        <span class="keyword">if</span> (str1.substr(<span class="number">0</span>, n) != str2) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> gcdOfStrings(str1.substr(n, m - n), str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/description/" target="_blank" rel="noopener">1072. Flip Columns For Maximum Number of Equal Rows</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：64.37%（216ms）</p><h3>题意</h3><p>给定一个只包含0和1的矩阵，可以选择矩阵的若干列，把它们的值翻转，问翻转后最多有几行会变成全0或全1？</p><h3>分析</h3><p>显然，每一行变成全0或全1只有两种可能：0全都被翻转成1，或者1全都被翻转成0。所以只需要用一个哈希表统计每种翻转方法一共对应了多少行。虽然每一行有两种可能的翻转方法，但很显然，这两种方法不会被重复计算。</p><p>另一种更有趣的方法是，把每一行都翻转到第一个位置的数为0，然后再进行统计，这样就可以减少总共需要的统计数量了。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mmap;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mmap[A[i]]++;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(A[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                B[j] = <span class="number">1</span> - B[j];</span><br><span class="line">            mmap[B]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: mmap)</span><br><span class="line">            ans = max(ans, p.second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/adding-two-negabinary-numbers/description/" target="_blank" rel="noopener">1073. Adding Two Negabinary Numbers</a></h2><p>标记难度：Medium</p><p>提交次数：1/3</p><p>代码效率：77.78%（12ms）</p><h3>题意</h3><p>将两个-2进制数相加。加数的长度不超过1000。</p><h3>分析</h3><p>开始做的时候没看到1000，写了一个转成十进制相加再转回来的方法，十分愚蠢。</p><p>前段时间的比赛中（<a href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-130/">Leetcode Weekly Contest 130总结</a>）也用到了-2进制。这种题其实也不太难，搞清楚如何适当地修改加法规则就可以了（那倒是和第一题有点像）。</p><p>假定当前的-2进制数<code>a</code>可以用<code>a[0] * (-2)^0 + a[1] * (-2)^1 + ... + a[n-1] * (-2)^(n-1)</code>来表示。在加法过程中，如果<code>a[i] &lt; 0</code>，则需要从<code>a[i + 1]</code>借位。此时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] * (<span class="number">-2</span>)^<span class="number">0</span> + ... + a[i]     * (<span class="number">-2</span>)^i + a[i+<span class="number">1</span>]     * (<span class="number">-2</span>)^(i+<span class="number">1</span>) + ... + a[n<span class="number">-1</span>] * (<span class="number">-2</span>)^(n<span class="number">-1</span>) =</span><br><span class="line">a[<span class="number">0</span>] * (<span class="number">-2</span>)^<span class="number">0</span> + ... + (a[i]+<span class="number">2</span>) * (<span class="number">-2</span>)^i + (a[i+<span class="number">1</span>]+<span class="number">1</span>) * (<span class="number">-2</span>)^(i+<span class="number">1</span>) + ... + a[n<span class="number">-1</span>] * (<span class="number">-2</span>)^(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>可以看出来，“借位”实际上是+1。同理，如果<code>a[i] &gt; 1</code>，则需要向<code>a[i + 1]</code>进位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] * (<span class="number">-2</span>)^<span class="number">0</span> + ... + a[i]     * (<span class="number">-2</span>)^i + a[i+<span class="number">1</span>]     * (<span class="number">-2</span>)^(i+<span class="number">1</span>) + ... + a[n<span class="number">-1</span>] * (<span class="number">-2</span>)^(n<span class="number">-1</span>) =</span><br><span class="line">a[<span class="number">0</span>] * (<span class="number">-2</span>)^<span class="number">0</span> + ... + (a[i]<span class="number">-2</span>) * (<span class="number">-2</span>)^i + (a[i+<span class="number">1</span>]<span class="number">-1</span>) * (<span class="number">-2</span>)^(i+<span class="number">1</span>) + ... + a[n<span class="number">-1</span>] * (<span class="number">-2</span>)^(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>“进位”实际上是-1。</p><p>然后直接参照普通的高精度加法写就可以了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; addNegabinary(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = B.size();</span><br><span class="line">        reverse(A.begin(), A.end());</span><br><span class="line">        reverse(B.begin(), B.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">        C.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            C[i] += (i &lt; n ? A[i] : <span class="number">0</span>) + (i &lt; m ? B[i] : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= n &amp;&amp; i &gt;= m &amp;&amp; C[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            C.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (C[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                C[i + <span class="number">1</span>]--;</span><br><span class="line">                C[i] -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (C[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                C[i + <span class="number">1</span>]++;</span><br><span class="line">                C[i] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">        reverse(C.begin(), C.end());</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/description/" target="_blank" rel="noopener">1074. Number of Submatrices That Sum to Target</a></h2><p>标记难度：Hard</p><p>提交次数：1/4</p><p>代码效率：73.10%（4084ms）</p><h3>题意</h3><p>给定一个矩阵，求其中和等于<code>target</code>的子矩阵的数量。</p><h3>分析</h3><p>这道题的思路和一维情形差不多。枚举子矩阵两列的边界，然后在行的意义上就降维到一维情形了。</p><p>至于一维情形，就是遍历数组，用一个哈希表记录已经访问过的前缀和，然后每次在哈希表中查找当前前缀和减<code>target</code>。</p><p>为了加速计算，可以计算出每行的前缀和。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> linePrefixSum[<span class="number">300</span>][<span class="number">300</span>];  <span class="comment">// 每行的前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            linePrefixSum[i][<span class="number">0</span>] = A[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">                linePrefixSum[i][j] = linePrefixSum[i][j<span class="number">-1</span>] + A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; m; j++) &#123;</span><br><span class="line">                LL sum = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;LL, <span class="keyword">int</span>&gt; lineMap;</span><br><span class="line">                lineMap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    sum += linePrefixSum[k][j] - (i &gt; <span class="number">0</span> ? linePrefixSum[k][i<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">auto</span> p = lineMap.find(sum - target);</span><br><span class="line">                    <span class="keyword">if</span> (p != lineMap.end())</span><br><span class="line">                        ans += p-&gt;second;</span><br><span class="line">                    lineMap[sum]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/greatest-common-divisor-of-strings/discuss/303781/Java-3-codes:-Recursive-iterative-and-regex-w-brief-comments-and-analysis." target="_blank" rel="noopener">Leetcode 1071 Solution - [Java] 3 codes: Recursive, iterative and regex w/ brief comments and analysis.</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/discuss/303752/Python-1-Line" target="_blank" rel="noopener">lee215's solution for Leetcode 1072 - [Python] 1 Line</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次还是比较简单的。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Math" scheme="https://zhanghuimeng.github.io/tags/alg-Math/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
      <category term="alg:Ad-Hoc" scheme="https://zhanghuimeng.github.io/tags/alg-Ad-Hoc/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 138总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-138/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-138/</id>
    <published>2019-05-26T20:39:18.000Z</published>
    <updated>2019-05-27T16:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得第3题最难。但是，好像比赛的时候第3题出锅了呢……</p><a id="more"></a><h2><a href="https://leetcode.com/problems/height-checker/description/" target="_blank" rel="noopener">1051. Height Checker</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：4ms</p><h3>题意</h3><p>给定一个数组，问其中没有正确归到排序后的位置的数有多少个。</p><h3>分析</h3><p>直接复制一个数组，排个序，和原来的数组比较一下就可以了。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sorted(heights);</span><br><span class="line">        sort(sorted.begin(), sorted.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (heights[i] != sorted[i])</span><br><span class="line">                ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. Grumpy Bookstore Owner</a></h2><p>标记难度：Easy</p><p>提交次数：2/3</p><p>代码效率：36ms</p><h3>题意</h3><p>给定一个整数数组，其中的一些位置被标记了。可以将连续<code>X</code>个位置的标记消去（只能消去一次）。问消去后未被标记的整数之和最大是多少？</p><h3>分析</h3><p>最暴力的做法是枚举每个开始消去的位置，复杂度是<code>O(N*X)</code>，但以本题<code>X, N &lt;= 20000</code>的数据规模显然是不行的。解决方案也很简单，计算原来所有没有被标记的整数的和，然后只算出在每个位置消去会增加的和，把两个加在一起取最大值就行了。而“每个位置消去会增加的和”这个东西可以从前往后递推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more[i+<span class="number">1</span>] = more[i] - grumpy[i<span class="number">-1</span>] * customers[i<span class="number">-1</span>] + grumpy[i+X<span class="number">-1</span>] * customers[i+X<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>复杂度是<code>O(N+X)</code>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> more[<span class="number">20005</span>];</span><br><span class="line">        <span class="keyword">int</span> n = customers.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!grumpy[i])</span><br><span class="line">                sum += customers[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        more[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X &amp;&amp; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i])</span><br><span class="line">                more[<span class="number">0</span>] += customers[i];</span><br><span class="line">        ans = max(ans, sum + more[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            more[i] = more[i<span class="number">-1</span>] - grumpy[i<span class="number">-1</span>] * customers[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + X - <span class="number">1</span> &lt; n)</span><br><span class="line">                more[i] += grumpy[i+X<span class="number">-1</span>] * customers[i+X<span class="number">-1</span>];</span><br><span class="line">            ans = max(ans, sum + more[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/previous-permutation-with-one-swap/description/" target="_blank" rel="noopener">1053. Previous Permutation With One Swap</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：112ms</p><h3>题意</h3><p>给定一个排列（可能有重复元素），求出只通过一次元素交换能得到的最大的比当前排列小的元素。</p><h3>分析</h3><p>比赛的时候我认为这道题很难，所以根本就没看题。后来发现并不难——显然，如果交换一次元素（不妨记为<code>(A[i], A[j])</code>）之后得到的元素比当前排列小，那么必然有<code>A[i] &gt; A[j]</code>。而且对于<code>A[j]</code>来说，<code>i</code>越大，得到的新排列越大（因为<code>A[j]</code>前面的其他元素都不变，那么变小的元素越靠后，得到的新排列就相应越大）。所以这道题就转换成了一个单调栈问题，对每个元素求出左侧比它大的最靠右的元素（不妨记为<code>maxIdx[j]</code>）。</p><p>求出来之后还需要一些讨论。对于不同的<code>j</code>，显然，<code>maxIdx[j]</code>越大，得到的新排列越大；而当<code>maxIdx[j1] == maxIdx[j2]</code>时，考虑以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">j1=<span class="number">3</span> -&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">j2=<span class="number">4</span> -&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>显然选择较小的<code>j</code>得到的新排列更大。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prevPermOpt1(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> maxIdx[<span class="number">10005</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">-1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? A[i] : <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || x &lt;= s.top().first) &#123;</span><br><span class="line">                s.emplace(x, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; x &gt; s.top().first) &#123;</span><br><span class="line">                    maxIdx[s.top().second] = i;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                s.emplace(x, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>, minVal;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxIdx[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (idx == <span class="number">-1</span>) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                minVal = A[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxIdx[i] &lt; maxIdx[idx]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maxIdx[i] &gt; maxIdx[idx] || maxIdx[i] == maxIdx[idx] &amp;&amp; A[i] &gt;= minVal) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                minVal = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意无解的情况</span></span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">-1</span>)</span><br><span class="line">            swap(A[maxIdx[idx]], A[idx]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/distant-barcodes/description/" target="_blank" rel="noopener">1054. Distant Barcodes</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：304ms</p><h3>题意</h3><p>给定<code>N</code>个整数，将这<code>N</code>个整数排成一排，使得没有两个相邻的数是相等的。</p><h3>分析</h3><p>我之前在CodeForces上做过这道题。下面是一个比较简单的贪心思路：统计每种整数的数量，放到一个以数量为关键字的堆里，然后每次取出堆顶元素放到结果数组中，将其数量减1（如果取出来的恰好是上一个取过的数就再取一个，然后把多取的再放回去）。复杂度是<code>O(N*log(N))</code>。</p><p>另一个思路是直接按照出现次数从多到少，把整数先放到结果数组的奇数位上，再放到偶数位上。不过这种思路的复杂度似乎没有降低，我也懒得去写了。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeBarcodes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; packages) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p: packages)</span><br><span class="line">            hMap[p]++;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p: hMap)</span><br><span class="line">            pq.emplace(p.second, p.first);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt1 = pq.top().first, num1 = pq.top().second;</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (!ans.empty() &amp;&amp; ans.back() == num1) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt2 = pq.top().first, num2 = pq.top().second;</span><br><span class="line">                pq.pop();</span><br><span class="line">                ans.push_back(num2);</span><br><span class="line">                cnt2--;</span><br><span class="line">                <span class="keyword">if</span> (cnt2 &gt; <span class="number">0</span>)</span><br><span class="line">                    pq.emplace(cnt2, num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(num1);</span><br><span class="line">                cnt1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt1 == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.emplace(cnt1, num1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/distant-barcodes/discuss/299225/Python-Set-Odd-Position-and-Even-Position" target="_blank" rel="noopener">lee215's Solution for Leetcode 1054 - [Python] Set Odd Position and  Even Position</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我觉得第3题最难。但是，好像比赛的时候第3题出锅了呢……&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="alg:Monotonic Stack" scheme="https://zhanghuimeng.github.io/tags/alg-Monotonic-Stack/"/>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 137总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-137/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-137/</id>
    <published>2019-05-19T20:31:33.000Z</published>
    <updated>2019-05-20T01:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>又是第四题不会做的一天。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/last-stone-weight/description/" target="_blank" rel="noopener">1046. Last Stone Weight</a></h2><p>标记难度：Easy</p><p>提交次数：1/2</p><p>代码效率：4ms</p><h3>题意</h3><p>给定<code>N</code>块石头的重量，每次可以取两块重量最大的石头，合成一块新石头（原来两块石头的重量不等，新石头的重量为原来的重量之差）或直接消去。问最后剩下的至多1块石头的重量？</p><h3>分析</h3><p>水题。直接模拟删除过程即可。用堆维护比较好，暴力也能过。我WA了一次是因为没看到<strong>没有剩余石头时返回0</strong>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s: stones)</span><br><span class="line">            pq.push(s);</span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">int</span> y = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            pq.push(<span class="built_in">abs</span>(x - y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !pq.empty() ? pq.top() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/description/" target="_blank" rel="noopener">1047. Remove All Adjacent Duplicates In String</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：20ms</p><h3>题意</h3><p>给定小写英文字母字符串<code>S</code>，在<code>S</code>上不断移除连续的两个相同字母，直到不能移除为止，问最后剩下的字符串长什么样子？</p><h3>分析</h3><p>直接把字符串当成一个栈来模拟就行了。显然，在移除两个字母之后，还有可能发生的消去只可能发生在被移除的字母的邻居上。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T.length() &gt; <span class="number">0</span> &amp;&amp; T.back() == c) T.pop_back();</span><br><span class="line">            <span class="keyword">else</span> T.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/longest-string-chain/description/" target="_blank" rel="noopener">1048. Longest String Chain</a></h2><p>标记难度：Medium</p><p>提交次数：1/2</p><p>代码效率：64ms</p><h3>题意</h3><p>给定一些由小写英文字母组成的单词，称单词1为单词2的祖先，当且仅当能在单词1中任意位置插入一个字母使得它与单词2相等。称单词链为一个单词序列，其中每一个单词都是后一个单词的祖先。问给定单词能够组成的单词链的最大长度。</p><h3>分析</h3><p>最开始我WA了一次，因为我没有意识到单词序列中的单词的顺序是任意的。之后我想了想——既然不同单词之间是否为祖先的关系是固定的，那么可以把这道题的问题化为在图上找最长路径。但这样化归我就不会做了……</p><p>所以我又想了想，显然，只有长度为<code>n-1</code>的单词才会有到长度为<code>n</code>的单词的边，所以这是一张层次图。所以只需要从长度为<code>n-1</code>的单词向长度为<code>n</code>的单词递推就好了……</p><p>为了写得更简单一些，甚至还可以不管上面这个关系，直接把所有单词按长度排序，然后按普通的最长递增子序列的方法来做。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPredecessor</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; word1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length();</span><br><span class="line">        <span class="keyword">if</span> (word2.length() != n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; word1[i] == word2[i]; i++);</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i] != word2[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.length() &lt; s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">bool</span> g[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = words.size();</span><br><span class="line">        sort(words.begin(), words.end(), cmp);</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPredecessor(words[i], words[j])) &#123;</span><br><span class="line">                    g[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (g[j][i])</span><br><span class="line">                    f[i] = max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            ans = max(f[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/last-stone-weight-ii/description/" target="_blank" rel="noopener">1049. Last Stone Weight II</a></h2><p>标记难度：Medium</p><p>提交次数：2/3</p><p>代码效率：4ms</p><h3>题意</h3><p>给定<code>N</code>块石头的重量，每次可以<strong>任取两块</strong>石头，合成一块新石头（原来两块石头的重量不等，新石头的重量为原来的重量之差）或直接消去（原来两块石头的重量不等）。问最后剩下的至多1块石头的重量最小是多少？</p><h3>分析</h3><p>这题我并不会做。于是我去看了看题解，大致看到了两种解法：</p><ul><li>把题目转化成背包问题：将背包中的物品分成两组，求两组的和之差的最小值<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li><li>直接求解前<code>i</code>块石头消去后可能得到的重量<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li></ul><p>第一种做法写起来很简单，就是用DP方法求出一个背包的和的所有可能值，然后直接用总和减去这些值，得到对应的另一个背包的和，然后求出对应的剩余价值。显然，每种石头合成方法都可以化归为一种背包消去方法。消去的过程类似下列式子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value = stones[i] + stones[j]</span><br><span class="line">value = value - stones[k] = stones[i] + stones[j] - stones[k]</span><br><span class="line">value = stones[l] - value = - stones[i] - stones[j] + stones[k] + stones[l]</span><br><span class="line">...</span><br><span class="line">value = ± stones[<span class="number">0</span>] ± stones[<span class="number">1</span>] ± stones[<span class="number">2</span>] ± ... ± stones[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>显然每一块石头不是被加上去了就是被消去了，把加上去的归到一个背包里，消去的归到另一个背包里即可。</p><p>后一种做法看起来更像一般的DP。令<code>dp[i][diff]</code>表示<code>stones[0..i]</code>是否能通过消去得到一块价值为<code>diff</code>的石头。显然，可能有以下三种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff&apos; + stones[i] = diff</span><br><span class="line">diff&apos; - stones[i] = diff</span><br><span class="line">stones[i] - diff&apos; = diff</span><br></pre></td></tr></table></figure><p>因此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][diff] = dp[i-1][diff - stones[i]] || dp[i-1][diff + stones[i]] || dp[i-1][stones[i] - diff]</span><br></pre></td></tr></table></figure><p>这两种做法的复杂度都是<code>O(N*S)</code>，其中<code>S</code>是<code>stones</code>数组的和。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> f[<span class="number">3005</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone: stones) &#123;</span><br><span class="line">            <span class="comment">// 这个顺序是很重要的，不然就把当前的stone加进去了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3000</span> - stone; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (f[i])</span><br><span class="line">                    f[i + stone] = <span class="literal">true</span>;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sum; i++)</span><br><span class="line">            <span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">                ans = min(ans, <span class="built_in">abs</span>(<span class="number">2</span> * i - sum));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">30</span>][<span class="number">3005</span>];  <span class="comment">// i, diff</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stones;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> diff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> diff == stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (diff &gt; <span class="number">3000</span> || diff &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[i][diff] != <span class="number">-1</span>) <span class="keyword">return</span> f[i][diff];</span><br><span class="line">        f[i][diff] = dp(i - <span class="number">1</span>, diff + stones[i]) || dp(i - <span class="number">1</span>, diff - stones[i]) || dp(i - <span class="number">1</span>, stones[i] - diff);</span><br><span class="line">        <span class="keyword">return</span> f[i][diff];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;stones = stones;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (dp(stones.size() - <span class="number">1</span>, i))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC++Python-Easy-Knapsacks-DP" target="_blank" rel="noopener">lee215's Solution for Leetcode 1049 - [Java/C++/Python] Easy Knapsacks DP</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://leetcode.com/problems/last-stone-weight-ii/discuss/294906/Variant-of-less956-Tallest-Billboardgreater.-Python-DP-with-explanation" target="_blank" rel="noopener">Variant of &lt;956 Tallest Billboard&gt;. Python DP with explanation</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是第四题不会做的一天。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Stack" scheme="https://zhanghuimeng.github.io/tags/alg-Stack/"/>
    
      <category term="alg:Heap" scheme="https://zhanghuimeng.github.io/tags/alg-Heap/"/>
    
      <category term="alg:Dynamic Programming" scheme="https://zhanghuimeng.github.io/tags/alg-Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 136总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-136/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-136/</id>
    <published>2019-05-12T01:14:56.000Z</published>
    <updated>2019-05-13T21:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得这场比赛最难的是第一道题……</p><a id="more"></a><h2><a href="https://leetcode.com/problems/robot-bounded-in-circle/description/" target="_blank" rel="noopener">1041. Robot Bounded In Circle</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：61.81%（4ms）</p><h3>题意</h3><p>给定一个方格图上的一个移动序列（包括移动和旋转两种操作），问该移动序列是否会产生循环（或者说回到原点之类的）。</p><h3>分析</h3><p>……比赛的时候看到这道题我就蒙了。</p><p>原题中问的是“never leaves the circle”，也就是机器人的移动是否是有界的；不过很显然这个可以翻译成是否必然会重复经过某个方格且行进方向重复，否则移动就不会是有界的了。从这个思路来想，最暴力的方法就是多重复走几轮，看会不会发生重复；如果发生了则必然会产生循环，如果不发生呢……？</p><p>事实上，上面这个思路是对的，而且最多走4轮就够了。具体参见<a href="https://leetcode.com/problems/robot-bounded-in-circle/discuss/290856/JavaC++Python-Let-Chopper-Help-Explain" target="_blank" rel="noopener">[Java/C++/Python] Let Chopper Help Explain</a>里的说明。如果非要严格证明的话，可以考虑每走一次时位移和相对方向的变化，不过这实在是比较麻烦。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(<span class="built_in">string</span> instructions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = instructions.size();</span><br><span class="line">        <span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N * <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instructions[i % N] == <span class="string">'L'</span>)</span><br><span class="line">                d = (d + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (instructions[i % N] == <span class="string">'R'</span>)</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = x + mx[d], y = y + my[d];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/flower-planting-with-no-adjacent/description/" target="_blank" rel="noopener">1042. Flower Planting With No Adjacent</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：80.35%（168ms）</p><h3>题意</h3><p>给定一个全部结点度数都&lt;4的无向图，要求对该图的结点进行4-染色，使得没有两个相邻结点的颜色是相同的。</p><h3>分析</h3><p>我最开始愣了一下，然后发现是4-染色，所以直接DFS染色就行了，一定可以染出一种可行解的……</p><p>P.S. 我觉得这个第二题可比第一题要简单。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">10001</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> found[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(found, <span class="number">0</span>, <span class="keyword">sizeof</span>(found));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y: G[x])</span><br><span class="line">            <span class="keyword">if</span> (color[y - <span class="number">1</span>] != <span class="number">0</span>)</span><br><span class="line">                found[color[y - <span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (!found[i]) &#123;</span><br><span class="line">                color[x - <span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y: G[x])</span><br><span class="line">            <span class="keyword">if</span> (color[y - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gardenNoAdj(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        color = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = paths[i][<span class="number">0</span>], y = paths[i][<span class="number">1</span>];</span><br><span class="line">            G[x].push_back(y);</span><br><span class="line">            G[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这个图可能不连通……</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="keyword">if</span> (color[i - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                dfs(i);</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/partition-array-for-maximum-sum/description/" target="_blank" rel="noopener">1043. Partition Array for Maximum Sum</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：36.60%（28ms）</p><h3>题意</h3><p>将数组<code>A</code>分成若干个连续子序列，每个子序列的长度不超过<code>K</code>，求（每个子序列长度×子序列中最大值）的和的最大值。</p><h3>分析</h3><p>这就是很传统的DP题了。令<code>f[i] = maxsum(0, 1, ..., i)</code>，则<code>f[i] = max(f[i - j] + maxn(f[i-j+1 ... i]) * j) (1 &lt;= j &lt;= K)</code>。预处理子序列的最大值可以将时间复杂度降低到<code>O(NK)</code>。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">501</span>];</span><br><span class="line">    <span class="keyword">int</span> maxn[<span class="number">501</span>][<span class="number">501</span>];  <span class="comment">// [i, i+j]内的最大值</span></span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        N = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            maxn[i][<span class="number">0</span>] = A[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; K &amp;&amp; i + j &lt; N; j++)</span><br><span class="line">                maxn[i][j] = max(maxn[i][j<span class="number">-1</span>], A[i+j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            f[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K &amp;&amp; j &lt;= i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = maxn[i - j + <span class="number">1</span>][j - <span class="number">1</span>] * j;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) x += f[i - j];</span><br><span class="line">                f[i] = max(f[i], x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/longest-duplicate-substring/" target="_blank" rel="noopener">1044. Longest Duplicate Substring</a></h2><p>标记难度：Hard</p><p>提交次数：3/6</p><p>代码效率：</p><ul><li>二分+RK：1508ms</li><li><code>O(n*log^2(n))</code>后缀数组：884ms</li><li><code>O(n*log(n))</code>后缀数组：404ms</li></ul><h3>题意</h3><p>给定字符串<code>S</code>，求出<code>S</code>中最长的重复出现的连续子串的长度。（子串可以重叠）</p><h3>分析</h3><p>这道题和<a href="https://www.luogu.org/problemnew/show/P2743" target="_blank" rel="noopener">P2743 [USACO5.1]乐曲主题Musical Themes</a>有点像，除了重复出现的定义之外。事实上有三种经典的做法：</p><ul><li>DP：这个idea是很显然的，但复杂度是<code>O(N^2)</code>，不适合这道题</li><li>二分+RK算法：容易想到，复杂度最好时为<code>O(N*log(N))</code></li><li>后缀数组：复杂度为<code>O(N*log(N))</code>（但我不会写）</li></ul><p>所以就先二分答案+RK算法好了。</p><p>显然，如果有长度为<code>n</code>的连续子串，那么也必然有长度为<code>n-1</code>的连续子串，因此二分答案是可行的。接下来的重点就是判断，是否有长度为<code>n</code>的重复子串。这个应用场景就很适合<a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm" target="_blank" rel="noopener">Rabin_Karp算法</a>了：</p>$$\begin{aligned}h_i &= (d^{m-1} * s_{i} + d^{m-2} * s_{i+1} + \cdots d * s_{i+m-2} + s_{i+m-1}) \bmod p \\h_{i+1} &= (d^{m} * s_{i+1} + d^{m-1} * s_{i+2} + \cdots d * s_{i+m-1} + s_{i+m}) \bmod p \\&= ((h_i - d^{m-1} * s{i}) * d + s_{i+m}) \bmod p\end{aligned}$$<p>对长度<code>n</code>进行二分，然后计算每个长度为$n$的子串的哈希值，然后检查其中是否有碰撞，并根据结果调整二分的范围。</p><hr><p>至于后缀数组，这个东西我也不太会，所以我参考了G4G上的一些文章：</p><ul><li><a href="https://www.geeksforgeeks.org/suffix-array-set-1-introduction/" target="_blank" rel="noopener">Suffix Array | Set 1 (Introduction)</a>：最navie版本的后缀数组创建（<code>O(n^2*log(n))</code>）和搜索（<code>O(m*log(n))</code>）</li><li><a href="https://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/" target="_blank" rel="noopener">Suffix Array | Set 2 (nLogn Algorithm)</a>：利用基数排序实现<code>O(n*log(n))</code>的后缀数组创建（如果不用基数排序，只能达到<code>O(n*log^2(N))</code>）</li><li><a href="https://www.geeksforgeeks.org/radix-sort/" target="_blank" rel="noopener">Radix Sort</a>：基数排序==</li><li><a href="https://www.geeksforgeeks.org/%C2%AD%C2%ADkasais-algorithm-for-construction-of-lcp-array-from-suffix-array/" target="_blank" rel="noopener">kasai’s Algorithm for Construction of LCP array from Suffix Array</a>：在<code>O(n)</code>内创建LCP数组</li></ul><p>不过鉴于在这道题中取LCP数组的最大值就够了，所以我暂时没去细究如何通过LCP在<code>O(m)</code>内进行查询……</p><h3>代码</h3><h4>二分+RK</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">    LL h[<span class="number">100001</span>];</span><br><span class="line">    <span class="built_in">string</span> S;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    </span><br><span class="line">    LL P = <span class="number">1e9</span> + <span class="number">7</span>, d = <span class="number">256</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算长度为len时的哈希值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        LL <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            h[<span class="number">0</span>] = (h[<span class="number">0</span>] * d + S[i]) % P;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">pow</span> = (<span class="built_in">pow</span> * d) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len &lt;= N; i++) &#123;</span><br><span class="line">            h[i] = ((h[i<span class="number">-1</span>] - S[i<span class="number">-1</span>] * <span class="built_in">pow</span>) % P + P) % P;</span><br><span class="line">            h[i] = (h[i] * d + S[i + len - <span class="number">1</span>]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIsSame</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">if</span> (S[x + i] != S[y + i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        calc(len);</span><br><span class="line">        <span class="comment">// 判断是否发生碰撞</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.find(h[i]) != hashMap.end()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x: hashMap[h[i]])</span><br><span class="line">                    <span class="keyword">if</span> (checkIsSame(i, x, len)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (len &gt; ans.size())</span><br><span class="line">                            ans = S.substr(i, len);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap[h[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDupSubstring</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;S = S;</span><br><span class="line">        N = S.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = S.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOk(m)) l = m;</span><br><span class="line">            <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isOk(l + <span class="number">1</span>)) l++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>后缀数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SuffixTree</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Suffix</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="keyword">int</span> rank[<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Suffix&amp; suffix1, <span class="keyword">const</span> Suffix&amp; suffix2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (suffix1.rank[<span class="number">0</span>] != suffix2.rank[<span class="number">0</span>]) <span class="keyword">return</span> suffix1.rank[<span class="number">0</span>] &lt; suffix2.rank[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (suffix1.rank[<span class="number">1</span>] != suffix2.rank[<span class="number">1</span>]) <span class="keyword">return</span> suffix1.rank[<span class="number">1</span>] &lt; suffix2.rank[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> suffix1.index &lt; suffix2.index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">char</span> s[MAXN];</span><br><span class="line">        <span class="keyword">int</span> suffix[MAXN];</span><br><span class="line">        Suffix suffixTmp[MAXN];</span><br><span class="line">        <span class="keyword">int</span> suffixInv[MAXN];</span><br><span class="line">        <span class="keyword">int</span> lcp[MAXN];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        </span><br><span class="line">        SuffixTree(<span class="keyword">const</span> <span class="keyword">char</span>* a) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(s, a);</span><br><span class="line">            n = <span class="built_in">strlen</span>(s);</span><br><span class="line">            buildSuffix();</span><br><span class="line">            buildLCP();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对前两个字母排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                suffixTmp[i].index = i;</span><br><span class="line">                suffixTmp[i].rank[<span class="number">0</span>] = s[i];</span><br><span class="line">                suffixTmp[i].rank[<span class="number">1</span>] = i &lt; n - <span class="number">1</span> ? s[i + <span class="number">1</span>] : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(suffixTmp, suffixTmp + n);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过前2^k个字母的排序得到前2^(k+1)个字母的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; k) &lt; n; k++) &#123;</span><br><span class="line">                <span class="comment">// 处理上一次的排序结果</span></span><br><span class="line">                <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> prevRank[<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 计算出上一次的真实rank</span></span><br><span class="line">                <span class="comment">// 注意Suffix::rank相同时，真实rank值也相同（不会+1）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (suffixTmp[i].rank[<span class="number">0</span>] != prevRank[<span class="number">0</span>] || suffixTmp[i].rank[<span class="number">1</span>] != prevRank[<span class="number">1</span>]))</span><br><span class="line">                        rank++;</span><br><span class="line">                    <span class="built_in">memcpy</span>(prevRank, suffixTmp[i].rank, <span class="keyword">sizeof</span>(prevRank));</span><br><span class="line">                    <span class="comment">// 将上一次的真实rank记录在rank[0]中，并建立倒排列表</span></span><br><span class="line">                    suffixTmp[i].rank[<span class="number">0</span>] = rank;</span><br><span class="line">                    suffixInv[suffixTmp[i].index] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="comment">// 将rank[1]赋值为s[i+(1&lt;&lt;k)...i+(1&lt;&lt;(k+1))-1]的rank，即新子串后半部分当前的rank</span></span><br><span class="line">                    <span class="keyword">int</span> nextIdx = suffixTmp[i].index + (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">                    <span class="keyword">int</span> nextRank;</span><br><span class="line">                    <span class="keyword">if</span> (nextIdx &gt;= n) nextRank = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> nextRank = suffixTmp[suffixInv[nextIdx]].rank[<span class="number">0</span>];</span><br><span class="line">                    suffixTmp[i].rank[<span class="number">1</span>] = nextRank;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// sort(suffixTmp, suffixTmp + n);</span></span><br><span class="line">                radixSort(suffixTmp, n);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                suffix[i] = suffixTmp[i].index;</span><br><span class="line">                suffixInv[suffix[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildLCP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> lastLCP = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 考虑s[i]的LCP</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// s[i]在后缀数组中是最后一个，所以它的lcp是0</span></span><br><span class="line">                <span class="keyword">if</span> (suffixInv[i] == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    lcp[suffixInv[i]] = <span class="number">0</span>;</span><br><span class="line">                    lastLCP = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// s[j]在后缀数组中恰好在s[i]后面</span></span><br><span class="line">                <span class="keyword">int</span> j = suffix[suffixInv[i] + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (i + lastLCP &lt; n &amp;&amp; j + lastLCP &lt; n &amp;&amp; s[i+lastLCP] == s[j+lastLCP])</span><br><span class="line">                    lastLCP++;</span><br><span class="line">                lcp[suffixInv[i]] = lastLCP;</span><br><span class="line">                <span class="comment">// 重复长度-1</span></span><br><span class="line">                <span class="keyword">if</span> (lastLCP &gt; <span class="number">0</span>)</span><br><span class="line">                    lastLCP--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Suffix tmp[MAXN];</span><br><span class="line">        <span class="keyword">int</span> cnt[MAXN];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(Suffix suffixes[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                countSort(suffixes, tmp, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(Suffix suffixes[], Suffix tmp[], <span class="keyword">int</span> n, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">int</span>* cnt2 = cnt + <span class="number">1</span>;  <span class="comment">// 处理-1的问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cnt2[suffixes[i].rank[digit]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                cnt2[i] += cnt2[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                tmp[--cnt2[suffixes[i].rank[digit]]] = suffixes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(suffixes, tmp, <span class="keyword">sizeof</span>(Suffix) * n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDupSubstring</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        SuffixTree suffixTree(S.c_str());</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">0</span>, index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suffixTree.lcp[i] &gt; maxn) &#123;</span><br><span class="line">                maxn = suffixTree.lcp[i];</span><br><span class="line">                <span class="comment">// 注意index</span></span><br><span class="line">                index = suffixTree.suffix[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">-1</span> ? <span class="string">""</span> : S.substr(index, maxn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我觉得这场比赛最难的是第一道题……&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="Leetcode Contest" scheme="https://zhanghuimeng.github.io/tags/Leetcode-Contest/"/>
    
      <category term="alg:Binary Search" scheme="https://zhanghuimeng.github.io/tags/alg-Binary-Search/"/>
    
      <category term="alg:Depth-first Search" scheme="https://zhanghuimeng.github.io/tags/alg-Depth-first-Search/"/>
    
      <category term="alg:Rabin-Karp" scheme="https://zhanghuimeng.github.io/tags/alg-Rabin-Karp/"/>
    
      <category term="alg:Suffix Array" scheme="https://zhanghuimeng.github.io/tags/alg-Suffix-Array/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.4.2: Pollutant Control（网络流）</title>
    <link href="https://zhanghuimeng.github.io/post/usaco-4-4-2-pollutant-control/"/>
    <id>https://zhanghuimeng.github.io/post/usaco-4-4-2-pollutant-control/</id>
    <published>2019-05-05T22:41:23.000Z</published>
    <updated>2019-05-06T15:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2>题意</h2><p>见<a href="https://www.luogu.org/problemnew/show/P1344" target="_blank" rel="noopener">洛谷P1344 追查坏牛奶 Pollutant Control</a>。</p><p>给定网络流图、源点和汇点，求最大流的值，以及边数最小且边的编号字典序最小的最小割。</p><a id="more"></a><h2>分析</h2><p>单纯算个最大流很简单（特别是在<code>N=32</code>的情况下）。于是我去学习了一下Dinic算法，写（chao）了一顿。</p><p>算个最小割也很简单。只要在算完最大流之后的残量网络上，从源点出发BFS/DFS，然后很快就可以把整个图分成S和T两个集合；从S出发，到T结束的所有饱和边就组成了最小割。（这么想来，这道题有点像<a href="/post/usaco-4-3-2-street-race/">USACO 4.3.2: Street Race（图）</a>）</p><p>但是算个边数最少的最小割比较难。众所周知，最小割和最大流并不是唯一的。解决方法是修改图中的容量：记原来的容量为函数$c(\cdot)$，现在的容量为$c'(\cdot) = |E + 1|c(\cdot) + 1$，则修改容量之后的最小割$Mincut(c')$仍然是原图的最小割，且边数最小。原因很容易理解：</p><p>$$Mincut(c') = \sum_{e \in P} c'(e) = \sum_{e \in P} (|E + 1|c(e) + 1) = |E + 1|\sum_{e \in P} c(e) + |P|$$</p><p>显然有$|P| \leq |E + 1|$，因此$Mincut(c')$最小时，$\sum_{e \in P} c(e)$一项必定也是最小的，且$|P|$也最小。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p>算个边数最少且字典序最小的最小割好像就更难了。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>在下图这个测试样例中，这看起来是个很大的问题：</p><p><img src="example.png" alt="测试样例"></p><p>所以我们需要继续修改图中的容量<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，变成$c'(\cdot) = |E + 1|2^{|E|}c(\cdot) + 2^{|E|} + 2^i$，其中$i$是边的编号。此时有</p>$$\begin{aligned}Mincut(c') &= \sum_{e \in P} c'(e) \\&= \sum_{e \in P} (|E + 1|2^{|E|}c(\cdot) + 2^{|E|} + 2^i) \\&= |E + 1|2^{|E|}\sum_{e \in P} c(e) + 2^{|E|}|P| + \sum_{e \in P}2^i\end{aligned}$$<p>显然这三项是互不影响的：$|P| &lt; |E + 1|$，且$\sum 2^i &lt; 2^{|E|}$。因此最小化上式就相当于在计算最小割的前提下（$|E + 1|2^{|E|}\sum_{e \in P} c(e)$）最小化最小割的边数（$2^{|E|}|P|$），在最小化边数的前提下再最小化字典序（$\sum_{e \in P}2^i$）。</p><p>然后就出现了一个小问题：题目范围是$E \leq 1000$，$|c(e)| \leq 2000000$，因此现在最大的权值就变成了差不多$2^{1000} \cdot 1000 \cdot 1000$这么大，必须要用高精度了。于是我又遇到了一点小问题：位数开多了USACO的内存会炸（我没压位），而且需要注意，算<code>pow</code>的时候不要爆数组长度……</p><p>我不确定这么做是不是最优解，但我觉得这个解法是正确的，所以姑且就这样吧。</p><h2>代码</h2><p>前面三百多行都是高精度，中间是网络流……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ID: zhanghu15</span></span><br><span class="line"><span class="comment">TASK: milk6</span></span><br><span class="line"><span class="comment">LANG: C++14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"milk6.out"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"milk6.in"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">355</span>;</span><br><span class="line">    <span class="keyword">int</span> digits[maxn];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> sign;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setByInt</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(digits, <span class="number">0</span>, <span class="keyword">sizeof</span>(digits));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) sign = <span class="number">-1</span>, x = -x;</span><br><span class="line">        <span class="keyword">else</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digits[len++] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setByChar</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO：没有考虑符号</span></span><br><span class="line">        <span class="built_in">memset</span>(digits, <span class="number">0</span>, <span class="keyword">sizeof</span>(digits));</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            digits[len - i - <span class="number">1</span>] = c[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setByBigInt</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = a.len;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sign = a.sign;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;digits, a.digits, <span class="keyword">sizeof</span>(a.digits));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">toLL</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        LL sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            sum = sum * <span class="number">10</span> + digits[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abs(a) &lt; abs(b)</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">lessThanSameSign</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.len &lt; b.len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.len &gt; b.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.digits[i] &lt; b.digits[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.digits[i] &gt; b.digits[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abs(a) &gt; abs(b)</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">moreThanSameSign</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.len &gt; b.len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.len &lt; b.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.digits[i] &gt; b.digits[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.digits[i] &lt; b.digits[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abs(a) + abs(b)</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> BigInt <span class="title">plusSameSign</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b)</span> </span>&#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.sign = <span class="number">1</span>;</span><br><span class="line">        c.len = max(a.len, b.len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.len; i++) &#123;</span><br><span class="line">            c.digits[i] += a.digits[i] + b.digits[i];</span><br><span class="line">            c.digits[i + <span class="number">1</span>] += c.digits[i] / <span class="number">10</span>;</span><br><span class="line">            c.digits[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c.digits[c.len] != <span class="number">0</span>)</span><br><span class="line">            c.len++;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abs(a) - abs(b)</span></span><br><span class="line">    <span class="comment">// guaranteed abs(a) &gt;= abs(b)</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> BigInt <span class="title">minusSameSign</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b)</span> </span>&#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.sign = <span class="number">1</span>;</span><br><span class="line">        c.len = max(a.len, b.len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.len; i++) &#123;</span><br><span class="line">            c.digits[i] += a.digits[i] - b.digits[i];</span><br><span class="line">            <span class="keyword">if</span> (c.digits[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                c.digits[i + <span class="number">1</span>]--;</span><br><span class="line">                c.digits[i] += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c.len &gt; <span class="number">0</span> &amp;&amp; c.digits[c.len - <span class="number">1</span>] == <span class="number">0</span>) c.len--;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">divisionByInt</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a, LL b, BigInt&amp; c, LL&amp; temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 负数除法</span></span><br><span class="line">        <span class="keyword">if</span> (lessThanSameSign(a, b)) &#123;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            temp = a.toLL();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) sign = <span class="number">-1</span>, b = -b;</span><br><span class="line">        c.len = a.len;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt; b &amp;&amp; c.len &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            temp = temp * <span class="number">10</span> + a[c.len - <span class="number">1</span>];</span><br><span class="line">            c.len--;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            c[i] = temp / b;</span><br><span class="line">            temp %= b;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) temp = temp * <span class="number">10</span> + a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        c.sign = a.sign * sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------constructors------------*/</span></span><br><span class="line"></span><br><span class="line">    BigInt() &#123;</span><br><span class="line">        <span class="comment">// 0的len为0……</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(digits, <span class="number">0</span>, <span class="keyword">sizeof</span>(digits));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt(LL x) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setByInt(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BigInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setByChar(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt(<span class="keyword">const</span> BigInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setByBigInt(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------basic operators------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, BigInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">char</span> c[maxn];</span><br><span class="line">        in &gt;&gt; c;</span><br><span class="line">        a.setByChar(c);</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> BigInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.sign == <span class="number">-1</span>) out &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            out &lt;&lt; a.digits[i];</span><br><span class="line">        <span class="keyword">if</span> (a.len == <span class="number">0</span>) out &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.sign == b.sign) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.sign == <span class="number">1</span>) <span class="keyword">return</span> lessThanSameSign(a, b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> !lessThanSameSign(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.sign &lt; b.sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">         <span class="keyword">if</span> (a.sign == b.sign) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.sign == <span class="number">1</span>) <span class="keyword">return</span> moreThanSameSign(a, b);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> !moreThanSameSign(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.sign &gt; b.sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.sign != b.sign || a.len != b.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">            <span class="keyword">if</span> (a.digits[i] != b.digits[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> LL&amp; b) &#123;</span><br><span class="line">        BigInt nb(b);</span><br><span class="line">        <span class="keyword">return</span> a == nb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> LL&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(a == b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单目-运算符</span></span><br><span class="line">    BigInt <span class="keyword">operator</span> - () <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">BigInt <span class="title">a</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line">            a.sign = -a.sign;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// implements the main logic of +</span></span><br><span class="line">    <span class="keyword">friend</span> BigInt <span class="keyword">operator</span> + (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.sign == b.sign) &#123;</span><br><span class="line">            BigInt c(plusSameSign(a, b));</span><br><span class="line">            c.sign = a.sign;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        BigInt c;</span><br><span class="line">        <span class="keyword">if</span> (lessThanSameSign(a, b)) &#123;</span><br><span class="line">            c = minusSameSign(b, a);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> (a.sign == <span class="number">1</span> &amp;&amp; b.sign == <span class="number">-1</span>)</span><br><span class="line">                c.sign = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.sign == <span class="number">-1</span> &amp;&amp; b.sign == <span class="number">1</span>)</span><br><span class="line">                c.sign = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            c = minusSameSign(a, b);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> (a.sign == <span class="number">1</span> &amp;&amp; b.sign == <span class="number">-1</span>)</span><br><span class="line">                c.sign = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.sign == <span class="number">-1</span> &amp;&amp; b.sign == <span class="number">1</span>)</span><br><span class="line">                c.sign = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> BigInt <span class="keyword">operator</span> - (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        BigInt minusb = -b;</span><br><span class="line">        <span class="keyword">return</span> a + minusb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> BigInt <span class="keyword">operator</span> * (<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.sign = a.sign * b.sign;</span><br><span class="line">        c.len = a.len + b.len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.len; j++) &#123;</span><br><span class="line">                c[i + j] += a[i] * b[j];</span><br><span class="line">                c[i + j + <span class="number">1</span>] += c[i + j] / <span class="number">10</span>;</span><br><span class="line">                c[i + j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (c[c.len] &gt; <span class="number">0</span>)</span><br><span class="line">            c.len++;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> BigInt <span class="keyword">operator</span> / (<span class="keyword">const</span> BigInt&amp; a, LL b) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> b &lt;= 0?</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 负数舍入？</span></span><br><span class="line">        BigInt c;</span><br><span class="line">        LL residual;</span><br><span class="line">        divisionByInt(a, b, c, residual);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> LL <span class="keyword">operator</span> % (<span class="keyword">const</span> BigInt&amp; a, LL b) &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        LL residual;</span><br><span class="line">        divisionByInt(a, b, c, residual);</span><br><span class="line">        <span class="keyword">return</span> residual;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------syntax sugars------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> digits[index]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> digits[index]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        a = a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> -= (BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        a = a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> *= (BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b) &#123;</span><br><span class="line">        a = a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> /= (BigInt&amp; a, <span class="keyword">const</span> LL&amp; b) &#123;</span><br><span class="line">        a = a / b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> %= (BigInt&amp; a, <span class="keyword">const</span> LL&amp; b) &#123;</span><br><span class="line">        a = a % b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------math functions------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> BigInt <span class="title">min</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a, <span class="keyword">const</span> BigInt&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> BigInt <span class="title">abs</span><span class="params">(<span class="keyword">const</span> BigInt&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function">BigInt <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">        c.sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> BigInt <span class="title">pow</span><span class="params">(<span class="keyword">const</span> BigInt&amp; x, BigInt a)</span> </span>&#123;</span><br><span class="line">        BigInt ans = <span class="number">1</span>;</span><br><span class="line">        BigInt p = x;</span><br><span class="line">        LL res;</span><br><span class="line">        BigInt b;</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b.setByInt(<span class="number">0</span>);</span><br><span class="line">            divisionByInt(a, <span class="number">2</span>, b, res);</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>) ans *= p;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p * p;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    BigInt cap, flow;</span><br><span class="line">    Edge(<span class="keyword">int</span> f, <span class="keyword">int</span> t, BigInt c, BigInt w) &#123;</span><br><span class="line">        from = f;</span><br><span class="line">        to = t;</span><br><span class="line">        cap = c;</span><br><span class="line">        flow = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">5005</span>];</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">5005</span>];</span><br><span class="line">    <span class="keyword">int</span> dist[<span class="number">5005</span>];</span><br><span class="line">    <span class="keyword">int</span> cur[<span class="number">5005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, BigInt cap)</span> </span>&#123;</span><br><span class="line">        edges.emplace_back(from, to, cap, <span class="number">0</span>);</span><br><span class="line">        edges.emplace_back(to, from, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(s);</span><br><span class="line">        visited[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x: G[u]) &#123;</span><br><span class="line">                Edge&amp; e = edges[x];</span><br><span class="line">                <span class="comment">// residual network</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[e.to] &amp;&amp; e.cap &gt; e.flow)  &#123;</span><br><span class="line">                    visited[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    dist[e.to] = dist[u] + <span class="number">1</span>;</span><br><span class="line">                    q.push(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x: 当前结点</span></span><br><span class="line">    <span class="comment">// a: 当前路径上所有弧的最小残量</span></span><br><span class="line">    <span class="function">BigInt <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, BigInt a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; "dfs: " &lt;&lt; x &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        BigInt flow = <span class="number">0</span>, f;</span><br><span class="line">        <span class="comment">// 保存每个结点x正在考虑的弧cur[x]，防止重复计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; e.cap &lt;&lt; ' ' &lt;&lt; e.flow &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (dist[x] + <span class="number">1</span> == dist[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e.flow += f;</span><br><span class="line">                edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">                flow += f;</span><br><span class="line">                a -= f;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInt <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInt flow = <span class="number">0</span>;</span><br><span class="line">        BigInt INF = <span class="built_in">pow</span>((BigInt) <span class="number">10</span>, <span class="number">350</span>);</span><br><span class="line">        <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; dist[i] &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;e: edges) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; e.from &lt;&lt; ' ' &lt;&lt; e.to &lt;&lt;' ' &lt;&lt; e.cap &lt;&lt; ' ' &lt;&lt; e.flow &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">            flow += dfs(s, INF);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; flow &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认编号为1-n</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mincut() &#123;</span><br><span class="line">        bfs();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cut;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            Edge&amp; e = edges[i];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; <span class="number">0</span> &amp;&amp; e.cap == e.flow &amp;&amp; visited[e.from] &amp;&amp; !visited[e.to])</span><br><span class="line">                cut.push_back(i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dinic dinic;</span><br><span class="line">LL N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    dinic.n = N;</span><br><span class="line">    dinic.s = <span class="number">1</span>;</span><br><span class="line">    dinic.t = N;</span><br><span class="line">    BigInt K = <span class="built_in">pow</span>((BigInt) <span class="number">2</span>, M), p = <span class="number">1</span>;</span><br><span class="line">    LL s, e, c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; origEdges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        fin &gt;&gt; s &gt;&gt; e &gt;&gt; c;</span><br><span class="line">        dinic.addEdge(s, e, M * K * c + K + p);</span><br><span class="line">        p *= <span class="number">2</span>;</span><br><span class="line">        origEdges.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    LL maxflow = <span class="number">0</span>;</span><br><span class="line">    dinic.maxflow();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mincut(dinic.mincut());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: mincut) &#123;</span><br><span class="line">        maxflow += origEdges[x];</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; maxflow &lt;&lt; <span class="string">' '</span> &lt;&lt; mincut.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x: mincut)</span><br><span class="line">        fout &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://pinkpurplepineapples.wordpress.com/2016/11/08/min-cut-with-minimal-edge-count/" target="_blank" rel="noopener">pinkpurplepineapples - Min Cut with fewest edges</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>此处原文为“If there are still multiple sets, choose the one whose initial routes have the smallest index.”。说实话，我不是很确定这句话到底是不是字典序的意思，但大概是吧。 <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>一种能通过所有样例的修改方法是$c'(\cdot) = |E + 1||K|c(\cdot) + |K| + i$，但我觉得只加一个$i$无法体现出字典序，因为可能有1+6 &gt; 2+3这种情况。我并没有实际去构造这样的反例，当然也没有证明这样的例子一定是不存在的。USACO上的题解说：“Then I split the first route in the min cut into two with the same source and end to check whether it can be replaced by routes with a smaller initial index. However, this solution won't work for multi-substitute cases, like the one below.”意思是他基本上也没管这个问题…… <a href="#fnref3" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;题意&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1344 追查坏牛奶 Pollutant Control&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;给定网络流图、源点和汇点，求最大流的值，以及边数最小且边的编号字典序最小的最小割。&lt;/p&gt;
    
    </summary>
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/categories/USACO/"/>
    
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/tags/USACO/"/>
    
      <category term="alg:Network Flow" scheme="https://zhanghuimeng.github.io/tags/alg-Network-Flow/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.4.1: Shuttle Puzzle（构造）</title>
    <link href="https://zhanghuimeng.github.io/post/usaco-4-4-1-shuttle-puzzle/"/>
    <id>https://zhanghuimeng.github.io/post/usaco-4-4-1-shuttle-puzzle/</id>
    <published>2019-05-03T02:09:42.000Z</published>
    <updated>2019-05-03T15:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题使用的构造法还是挺有意思的。</p><a id="more"></a><h2>题意</h2><p>见<a href="https://www.luogu.org/problemnew/show/P2739" target="_blank" rel="noopener">洛谷 P2739 棋盘游戏 Shuttle Puzzle</a>。</p><p>给定一个有<code>2N+1</code>个孔的棋盘，上面放着<code>N</code>个白色棋子和<code>N</code>个黑色棋子，初始状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WW..W_B..BB</span><br></pre></td></tr></table></figure><p>目标状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BB..B_W..WW</span><br></pre></td></tr></table></figure><p>只能进行两种操作：</p><ul><li>将空孔一侧的棋子移入孔中</li><li>将棋子跳过另<strong>一枚</strong>棋子，进入空孔中</li></ul><p>用每次移动的棋子在棋盘上的位置表示一次移动，求出移动次数最小且字典序最小的移动步骤。</p><h2>分析</h2><p>这道题看起来像是搜索（实际上，用搜索确实也能做），实际上应该用构造法。题目里已经给了<code>N=3</code>时的正解：</p><!-- ↷ ↶ → ← --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WWW BBB  3 W→</span><br><span class="line">WW WBBB  5 B↶</span><br><span class="line">WWBW BB  6 B←</span><br><span class="line">WWBWB B  4 W↷</span><br><span class="line">WWB BWB  2 W↷</span><br><span class="line">W BWBWB  1 W→</span><br><span class="line"> WBWBWB  3 B↶</span><br><span class="line">BW WBWB  5 B↶</span><br><span class="line">BWBW WB  7 B↶</span><br><span class="line">BWBWBW   6 W→</span><br><span class="line">BWBWB W  4 W↷</span><br><span class="line">BWB BWW  2 W↷</span><br><span class="line">B BWBWW  3 B←</span><br><span class="line">BB WBWW  5 B↶</span><br><span class="line">BBBW WW  4 W→</span><br><span class="line">BBB WWW</span><br></pre></td></tr></table></figure><p>显然可以看出棋盘的变化是前后对称的，而且总移动步数是<code>(N + 1)^2</code>。</p><p>我自己从中（经过多次试错和在纸上的模拟）总结出的规律是：</p><ul><li>按照<code>W→</code>，<code>B↶</code>，<code>B←</code>，<code>W↷</code>的顺序进行移动</li><li>右移W时，如果是总移动步数前半部分的移动，只在空格右侧不是W时移动；左移B时同理</li><li>向右跳W时，不跳过W；左跳B时同理</li></ul><p>然后直接模拟就可以了。</p><p>不过，显然还有更好的方法。如果盯着这个棋盘变化表多看一会儿，会发现空格的位置是有规律的，好像形成了几条斜线（下面两张图摘自USACO题解）：</p><p><img src="prob27.gif" alt="移动棋子的位置"></p><p><img src="prob27a.gif" alt="把上述位置连起来"></p><p>空格位置的变化和每一步移动的棋子的位置实际上是相同的（<code>N = 3</code>，把第一步也算上）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 5 6 4 2 1 3 5 7 6 4 2 3 5 4</span><br></pre></td></tr></table></figure><p>可以看出，上述数列是若干个等差数列的组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 ; 3 5 ; 6 4 2 ; 1 3 5 7 ; 6 4 2 ; 3 5 ; 4</span><br></pre></td></tr></table></figure><p>根据类似的规律，也可以进行求解。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ID: zhanghu15</span></span><br><span class="line"><span class="comment">TASK: shuttle</span></span><br><span class="line"><span class="comment">LANG: C++14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"shuttle.out"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"shuttle.in"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> state[<span class="number">200</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> space[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        state[<span class="number">0</span>][i] = <span class="string">'W'</span>;</span><br><span class="line">    state[<span class="number">0</span>][N] = <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N + <span class="number">1</span>; i &lt;= <span class="number">2</span>*N; i++)</span><br><span class="line">        state[<span class="number">0</span>][i] = <span class="string">'B'</span>;</span><br><span class="line">    space[<span class="number">0</span>] = N;</span><br><span class="line"></span><br><span class="line">    M = (N + <span class="number">1</span>) * (N + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 使用了类似于状态机的思路</span></span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; M - <span class="number">1</span>; m++) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(state[m + <span class="number">1</span>], state[m], <span class="keyword">sizeof</span>(state[m]));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// move W right</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (space[m] &gt; <span class="number">0</span> &amp;&amp; state[m][space[m] - <span class="number">1</span>] == <span class="string">'W'</span> &amp;&amp;</span><br><span class="line">                    (m &gt;= M/<span class="number">2</span> || space[m] == <span class="number">2</span>*N || state[m][space[m] + <span class="number">1</span>] != <span class="string">'W'</span>)) &#123;</span><br><span class="line">                    swap(state[m + <span class="number">1</span>][space[m]], state[m + <span class="number">1</span>][space[m] - <span class="number">1</span>]);</span><br><span class="line">                    space[m + <span class="number">1</span>] = space[m] - <span class="number">1</span>;</span><br><span class="line">                    moves[m] = space[m] - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// jump B left</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (space[m] + <span class="number">2</span> &lt;= <span class="number">2</span>*N &amp;&amp; state[m][space[m] + <span class="number">2</span>] == <span class="string">'B'</span> &amp;&amp; state[m][space[m] + <span class="number">1</span>] != <span class="string">'B'</span>) &#123;</span><br><span class="line">                    swap(state[m + <span class="number">1</span>][space[m]], state[m + <span class="number">1</span>][space[m] + <span class="number">2</span>]);</span><br><span class="line">                    space[m + <span class="number">1</span>] = space[m] + <span class="number">2</span>;</span><br><span class="line">                    moves[m] = space[m] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// move B left</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (space[m] + <span class="number">1</span> &lt;= <span class="number">2</span>*N &amp;&amp; state[m][space[m] + <span class="number">1</span>] == <span class="string">'B'</span> &amp;&amp;</span><br><span class="line">                    (m &gt;= M/<span class="number">2</span> || space[m] == <span class="number">0</span> || state[m][space[m] - <span class="number">1</span>] != <span class="string">'B'</span>)) &#123;</span><br><span class="line">                    swap(state[m + <span class="number">1</span>][space[m]], state[m + <span class="number">1</span>][space[m] + <span class="number">1</span>]);</span><br><span class="line">                    space[m + <span class="number">1</span>] = space[m] + <span class="number">1</span>;</span><br><span class="line">                    moves[m] = space[m] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// jump W right</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (space[m] - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; state[m][space[m] - <span class="number">2</span>] == <span class="string">'W'</span> &amp;&amp; state[m][space[m] - <span class="number">1</span>] != <span class="string">'W'</span>) &#123;</span><br><span class="line">                    swap(state[m + <span class="number">1</span>][space[m]], state[m + <span class="number">1</span>][space[m] - <span class="number">2</span>]);</span><br><span class="line">                    space[m + <span class="number">1</span>] = space[m] - <span class="number">2</span>;</span><br><span class="line">                    moves[m] = space[m] - <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; state[m + <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">20</span> != <span class="number">0</span>) fout &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">20</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fout &lt;&lt; moves[i] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题使用的构造法还是挺有意思的。&lt;/p&gt;
    
    </summary>
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/categories/USACO/"/>
    
    
      <category term="USACO" scheme="https://zhanghuimeng.github.io/tags/USACO/"/>
    
      <category term="alg:Ad-Hoc" scheme="https://zhanghuimeng.github.io/tags/alg-Ad-Hoc/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 133总结</title>
    <link href="https://zhanghuimeng.github.io/post/leetcode-weekly-contest-133/"/>
    <id>https://zhanghuimeng.github.io/post/leetcode-weekly-contest-133/</id>
    <published>2019-04-22T00:19:52.000Z</published>
    <updated>2019-04-28T19:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>我对于以后面试的时候不需要默写AC自动机如同不需要默写KMP一样自信，不需要默写KMP如同不需要默写快排一样自信，换句话说，就是我一点也不自信。也许以后还得当场讲清红黑树插入的几种情况呢。</p><a id="more"></a><h2><a href="https://leetcode.com/problems/matrix-cells-in-distance-order/description/" target="_blank" rel="noopener">1030. Matrix Cells in Distance Order</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：132ms</p><h3>题意</h3><p>给定一个<code>R</code>行<code>C</code>列方格图，把其中的所有方格按照到坐标<code>(r0, c0)</code>的曼哈顿距离排序。</p><h3>分析</h3><p>当然可以把所有方格枚举出来然后排个序；不过完全没有这样的必要，可以直接在<code>(r0, c0)</code>周围绕圈。</p><h3>代码</h3><p>不过还是直接排序来得快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> d = <span class="built_in">abs</span>(i - r0) + <span class="built_in">abs</span>(j - c0);</span><br><span class="line">                    ans.push_back(&#123;d, i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">        sort(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line">            ans[i].erase(ans[i].begin());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/two-city-scheduling/description/" target="_blank" rel="noopener">1029. Two City Scheduling</a></h2><p>标记难度：Easy</p><p>提交次数：1/1</p><p>代码效率：</p><ul><li>DP：8ms</li><li>贪心：4ms</li></ul><h3>题意</h3><p>共有<code>2N</code>个人要坐飞机去A城或B城，给定每个人去每个城市的代价，求恰有<code>N</code>个人去A时的最小代价。</p><h3>分析</h3><p>题面看起来像一道典型的贪心问题，虽然我比赛的时候并没有意识到，于是首先写了一个DP：<code>f[n][m]</code>表示在前<code>n</code>个人中共有<code>m</code>个人去<code>A</code>城时的最小代价。转移方程是<code>f[n][m] = min(f[n-1][m] + cost[n][1], f[n-1][m-1] + cost[n][0])</code>。注意下标。</p><p>贪心的思路也很简单：不妨假设随便分配了<code>N</code>个人去A城，然后对这个解加以优化：显然，如果去A城的人中存在<code>i</code>，去B城的人中存在<code>j</code>，使得<code>cost[i][0] + cost[j][1] &gt; cost[i][1] + cost[j][0]</code>，即<code>cost[i][0] - cost[i][1] &gt; cost[j][0] - cost[j][1]</code>，则应该把这两个人交换一下。结论就是，把所有人按<code>cost[i][0] - cost[i][1]</code>升序排序，然后取前一半去A城就行了。</p><h3>代码</h3><h4>DP</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">105</span>][<span class="number">105</span>]; <span class="comment">// f[n][m]: m people goes to A in the first n people</span></span><br><span class="line">        <span class="keyword">int</span> n = costs.size();</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + costs[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1e9</span>;</span><br><span class="line">                <span class="comment">// 注意这个条件==</span></span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= j) f[i][j] = min(f[i][j], f[i<span class="number">-1</span>][j] + costs[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                f[i][j] = min(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + costs[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][n / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4>贪心</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort in asending order of A - B</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; indices;</span><br><span class="line">        <span class="keyword">int</span> n = costs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            indices.emplace_back(costs[i][<span class="number">0</span>] - costs[i][<span class="number">1</span>], i);</span><br><span class="line">        sort(indices.begin(), indices.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">            ans += costs[indices[i].second][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            ans += costs[indices[i].second][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/description/" target="_blank" rel="noopener">1031. Maximum Sum of Two Non-Overlapping Subarrays</a></h2><p>标记难度：Medium</p><p>提交次数：1/1</p><p>代码效率：57.11%（12ms）</p><h3>题意</h3><p>给定数组<code>A</code>，返回<code>A</code>中两个长度分别为<code>L</code>和<code>M</code>的不相交子数组的和的最大值。</p><h3>分析</h3><p>我觉得这道题还是很简单的。</p><p>对<code>A</code>中的每个index，求出它左边的长度为<code>L</code>和<code>M</code>的子数组的和的最大值，以及它右边的长度为<code>L</code>和<code>M</code>的子数组的和的最大值，然后即可求出左边长度为<code>L</code>的子数组+右边长度为<code>M</code>的子数组的和的最大值，以及左边长度为<code>M</code>的子数组+右边长度为<code>L</code>的子数组的和的最大值。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> prefix[<span class="number">1005</span>], maxLbefore[<span class="number">1005</span>], maxLafter[<span class="number">1005</span>], maxMbefore[<span class="number">1005</span>], maxMafter[<span class="number">1005</span>];</span><br><span class="line">    <span class="comment">// 求子数组和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = prefix[r];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">0</span>) ans -= prefix[l - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prefix[i] = i == <span class="number">0</span> ? <span class="number">0</span> : prefix[i<span class="number">-1</span>];</span><br><span class="line">            prefix[i] += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &lt;=</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxLbefore[i] = i == <span class="number">0</span> ? <span class="number">-1</span> : maxLbefore[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= L - <span class="number">1</span>)</span><br><span class="line">                maxLbefore[i] = max(maxLbefore[i], get(i - L + <span class="number">1</span>, i));</span><br><span class="line">            maxMbefore[i] = i == <span class="number">0</span> ? <span class="number">-1</span> : maxMbefore[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= M - <span class="number">1</span>)</span><br><span class="line">                maxMbefore[i] = max(maxMbefore[i], get(i - M + <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;=</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxLafter[i] = i == n - <span class="number">1</span> ? <span class="number">-1</span> : maxLafter[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + L &lt;= n)</span><br><span class="line">                maxLafter[i] = max(maxLafter[i], get(i, i + L - <span class="number">1</span>));</span><br><span class="line">            maxMafter[i] = i == n - <span class="number">1</span> ? <span class="number">-1</span> : maxMafter[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + M &lt;= n)</span><br><span class="line">                maxMafter[i] = max(maxMafter[i], get(i, i + M - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans = max(ans, maxLbefore[i] + maxMafter[i + <span class="number">1</span>]);</span><br><span class="line">            ans = max(ans, maxMbefore[i] + maxLafter[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><a href="https://leetcode.com/problems/stream-of-characters/description/" target="_blank" rel="noopener">1032. Stream of Characters</a></h2><p>标记难度：Hard</p><p>提交次数：1/1</p><p>代码效率：</p><ul><li>Trie：27.69%（536ms）</li><li>AC自动机：没写</li></ul><h3>题意</h3><p>事先给定一个词表，然后给你一个字符流，在中间任意时刻查询，要求返回该字符流当前末尾能否与词表中某一个词匹配。</p><p>词表大小为1-2000，词的长度为1-2000，查询次数在40000次内。</p><h3>分析</h3><p>在知道可以用Trie之后，这道题其实很简单：首先造个Trie，把所有词都倒过来之后插进去；然后对字符流也倒着处理。这样做的主要原因就是，题目要求返回的是字符流的后缀能否与词匹配，这和Trie使用前缀的本质正好是相反的，那就全都反着做好了。这样每次查询的复杂度就是线性的了。</p><p>至于<a href="https://leetcode.com/problems/stream-of-characters/discuss/278842/C++-AC-Automaton-Solution-%28Amortized-time-complexity-O%281%29%29" target="_blank" rel="noopener">AC自动机的那些做法</a>，实在是太过分了（虽然在这道题下是更适当的应用场景），如果我以后得做默写AC自动机的面试题，那我恐怕很快就要毕业即失业了。当然，了解一下是很好的。</p><h3>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">        TrieNode* child[<span class="number">26</span>];</span><br><span class="line">        TrieNode() &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">memset</span>(child, <span class="number">0</span>, <span class="keyword">sizeof</span>(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">        TrieNode* root;</span><br><span class="line">        Trie() &#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">            TrieNode* p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;child[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                    p-&gt;child[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                p = p-&gt;child[c - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">            TrieNode* p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;child[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                p = p-&gt;child[c - <span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;isEnd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Trie trie;</span><br><span class="line">    <span class="built_in">string</span> q;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StreamChecker(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word: words) &#123;</span><br><span class="line">            reverse(word.begin(), word.end());</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">        q = letter + q;</span><br><span class="line">        <span class="keyword">if</span> (q.length() &gt; <span class="number">2000</span>) q = q.substr(<span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> trie.find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我对于以后面试的时候不需要默写AC自动机如同不需要默写KMP一样自信，不需要默写KMP如同不需要默写快排一样自信，换句话说，就是我一点也不自信。也许以后还得当场讲清红黑树插入的几种情况呢。&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://zhanghuimeng.github.io/tags/Leetcode/"/>
    
      <category term="alg:Greedy" scheme="https://zhanghuimeng.github.io/tags/alg-Greedy/"/>
    
      <category term="alg:Trie" scheme="https://zhanghuimeng.github.io/tags/alg-Trie/"/>
    
      <category term="alg:Aho–Corasick Algorithm" scheme="https://zhanghuimeng.github.io/tags/alg-Aho%E2%80%93Corasick-Algorithm/"/>
    
  </entry>
  
</feed>
